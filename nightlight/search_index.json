[["introduction.html", "Exploring Nighttime Light in the U.S. Southeast Model specification and evaluation in the tidymodels framework 1 Introduction 1.1 Questions 1.2 Method 1.3 Causal assumptions", " Exploring Nighttime Light in the U.S. Southeast Model specification and evaluation in the tidymodels framework Daniel Moul 2021-09-04 1 Introduction Nighttime lights are an indicator of human presence and have been used for analyzing economic trends in GDP, population, electricity consumption, \\(CO_2\\) emissions, and other dimensions of human activity and organization(Proville 2017). The Earth Observation Group (EOG), now at the Colorado School of Mines, makes available average nighttime light products covering much of the world, derived from data collected by the Defense Meteorological Satellite Program’s primary instrument, the Operational Linescan System (DMSP-OLS), employing Visible and Near-Infrared (VNIR) band sensors(Elvidge 1997). Data from this satellite series was collected 1992-2013. DMSP satellites are in sun-synchronized polar orbit at approximately 458 nautical miles(“FACT SHEET: Defense Meteorological Satellite Program” 2003). DMSP Satellite image. Source: NOAA 1.1 Questions Using the EOG’s average radiance products(Hsu et al. 2015) with focus on the southeastern United States (where I live): With what accuracy can I associate average night radiance values with human presence? Using the models identified in (1), how well can I use average night radiance to predict the same dimension(s) of human presence 10 years later? 1.2 Method Use data in the form of GeoTIFF files from the Nighttime Lights time series The files are cloud-free composites made using all the available archived DMSP-OLS smooth resolution data for calendar years. In cases where two satellites were collecting data - two composites were produced. The products are 30 arc second grids, spanning -180 to 180 degrees longitude and -65 to 75 degrees latitude. Specifically I will use Radiance Calibrated values rather than Digital Number (DN) values. See Radiance data and Intercalibration. Limit my focus to the southeastern states of the USA and census data from the years 2000 and 2010. As indicators of “human presence” I use data from the US Census Bureau: (A) demographic information (population and median income) and (B) geographic information (legal state and county borders from the TIGER/Line Shapefiles database), all retrieved using the tidycensus and tigris R packages. Associate each pixel (radiance value) in the GeoTIFF image with a county based on its position within county borders and calculate average light level per county. Similarly, calculate county land area based on county borders. Explore models with linear and non-linear associations among county average light levels and county-level demographic data, including transformations of the demographic data to improve linear relationships. Partition the data into two sets: (1) train-test set and (2) a holdout set for final model evaluation. Using the best model(s) identified in the prior step, evaluate model performance on 2010 census data, using the EOG’s intercalibration coefficients to enable valid, multi-year comparisons of radiance levels. 1.3 Causal assumptions In this endeavor, causal relationships are largely unknown and may be highly confounded. Unknown colliders may have large effects. I use only one or two predictor variables, and given the subject matter, there are more than the usual limitations of observational studies. dag &lt;- dagitty( &#39;dag{ rad [response, pos=&quot;1,0&quot;] pop [exposure, pos=&quot;3,0&quot;] env [response, pos=&quot;2,0&quot;] U_env [unobserved, pos=&quot;2,1&quot;] U_rad [unobserved, pos=&quot;1,1&quot;] U_pop [unobserved, pos=&quot;3,1&quot;] U_pe [unobserved, pos=&quot;2.5,-0.5&quot;] U_er [unobserved, pos=&quot;1.5,-0.5&quot;] U_env -&gt; env rad &lt;- env &lt;- pop U_pop -&gt; pop U_rad -&gt; rad pop -&gt; U_pe -&gt; env env -&gt; U_er -&gt; rad }&#39;) ggdag(dag) + theme(panel.grid.major = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank()) + labs(title = &quot;Proposed causal graph&quot;, x = NULL, y = NULL) Figure 1.1: Causal graph: there are many confounders and colliders My conjecture is that greater population density (pop) creates a larger, denser built environment (env) which in turn creates more nightlight (rad). Likely there are unobserved influences (confounders) and sources of error on the measured nightlight (U_rad), including some related to the satellites’ sensors and EOG’s algorithms for determining average nightlight values, radiance values, and intercalibration coefficients. There are many unobserved confounders on population density, including economic conditions, economic growth in various sectors, geography, and zoning laws. Additionally, some of these influences may not have remained constant between 2000 and 2010. There likely are unknown colliders (U_pe and U_er) that mediate the influence of population density on the built environment and the built environment on radiance. I assume the effect of U_rad is much smaller than U_env, U_c, and U_er. In this case U_pop is not relevant, and similarly, I ignore any influences that mediate changes in population that might change the association between population changes and population density changes. Given all the above, and the fact that I am building models for a relatively small geographic area and with only one year’s data (and then comparing to only one other year’s data), I do not expect highly accurate predictions. References "],["exploratory-data-analysis.html", "2 Exploratory data analysis 2.1 Map 2.2 Data for modeling", " 2 Exploratory data analysis c_focus &lt;- tar_read(census_focus_df) county_boundaries_terra &lt;- as(tar_read(census_focus_df),&quot;Spatial&quot;) state_boundaries_terra &lt;- as(tar_read(state_boundaries_geom),&quot;Spatial&quot;) state_list &lt;- glue_collapse(sort(unique(c_focus$state)), sep = &#39;, &#39;, last = &quot; and &quot;) 2.1 Map Specifically, I look at the 859 counties in 9 states: AL, GA, KY, MS, NC, SC, TN, VA and WV. It’s interesting to note that in nearly every county there is one main spot of light. Typically this city or town is the county seat of government and locus of economic activity. Radiance values span a wider range than this visible image suggests. # following the pattern at https://rspatial.org/terra/rs/2-exploration.html f1 &lt;- rast(source_light_file_2000) my_bbox &lt;- tar_read(bbox_vec) e &lt;- ext(as.numeric(c(my_bbox$xmin, my_bbox$xmax, my_bbox$ymin, my_bbox$ymax))) f2 &lt;- crop(f1, e) plotRGB(f2, r = 1, g = 1, b = 1, scale = 255, stretch = &quot;lin&quot;) plot(county_boundaries_terra, border = &quot;#fffdd0&quot;, lwd = 0.25, add = TRUE) # cream color plot(state_boundaries_terra, border = &quot;#fffdd0&quot;, add = TRUE) # cream color Figure 2.1: Average nightlight in the S.E. United States in 2000 2.2 Data for modeling # models_df &lt;- tar_read(models) data_df &lt;- tar_read(all_df) %&gt;% #fix NAs mutate(atotal = if_else(!is.na(atotal), atotal, calc_area), pop_density_official = if_else(!is.na(pop_density_official), pop_density_official, pop_density)) %&gt;% # drop a small number of apparent data errors filter(light_avg &gt; 1e-5) county_light_sf &lt;- tar_read(county_sf) d_df &lt;- data_df %&gt;% dplyr::select(state:pop_density_official) %&gt;% mutate(area_diff_pct = calc_area / atotal - 1, pop_densisty_diff_pct = pop_density / pop_density_official - 1) 2.2.1 Predictors and data transformations I have a plausible causal conjecture for two easily accessible variables associated with “human presence” such that we can use radiance to predict them: pop_density: the more people that live in a unit area, the more built out the area will be; the more built out an area is, the more light generated in that area medincome: the wealthier people are, the more light they will generate pop_density and medincome likely are correlated, so I may use only one of them. Since associations are reflexive, we can work from the data we have (predictor(s)) to the outcome we seek (response). In this case: using light to predict population density. In the plots below, the blue line is a LOESS curve (locally estimated scatterplot smoothing), the red line a straight regression line. Figures 2.2 to 2.5 show that light_avg and pop_density work best on a log scale. # light as predictor d_df %&gt;% ggplot() + geom_point(aes(light_avg, pop_density, color = state), alpha = 0.5) + geom_smooth(aes(light_avg, pop_density, ), se = FALSE, size = 0.5) + geom_smooth(aes(light_avg, pop_density, ), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = scales::label_number_si()) + labs(title = &quot;pop_density by light_avg&quot;) Figure 2.2: light_avg by pop_density (all states) d_df %&gt;% ggplot(aes(light_avg, pop_density)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_y_continuous(labels = scales::label_number_si()) + facet_wrap(~state)+ labs(title = &quot;pop_density by light_avg&quot;) Figure 2.3: light_avg by pop_density (faceted by state) d_df %&gt;% ggplot() + geom_point(aes(light_avg, pop_density, color = state), alpha = 0.5) + geom_smooth(aes(light_avg, pop_density), se = FALSE, size = 0.5) + geom_smooth(aes(light_avg, pop_density), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10() + scale_y_log10(labels = scales::label_number_si()) + labs(title = &quot;log_light_avg by log_pop_density&quot;, y = &quot;pop_density (log10 scale)&quot;, x = &quot;light_avg (log10 scale)&quot;) Figure 2.4: log_light_avg by log_pop_density (all states) d_df %&gt;% ggplot(aes(light_avg, pop_density)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10() + scale_y_log10(labels = scales::label_number_si()) + facet_wrap(~state)+ labs(title = &quot;log_light_avg by log_pop_density&quot;, y = &quot;pop_density (log10 scale)&quot;, x = &quot;light_avg (log10 scale)&quot;) Figure 2.5: log_pop_density by log_light_avg (faceted by state) Figures 2.6 to 2.8 show that medincome also works best on a log scale. # median income as predictor d_df %&gt;% ggplot() + geom_point(aes(light_avg, medincome, color = state), alpha = 0.5) + geom_smooth(aes(light_avg, medincome), se = FALSE, size = 0.5) + geom_smooth(aes(light_avg, medincome), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_y_continuous(labels = scales::label_number_si()) + # scale_y_log10() + #facet_wrap(~state)+ labs(title = &quot;medincome by light_avg&quot;, subtitle = glue(&quot;correlation: {round(cor(d_df$pop_density, d_df$medincome), 2)}&quot;)) Figure 2.6: medincome by light_avg (all states) d_df %&gt;% ggplot() + geom_point(aes(light_avg, medincome, color = state), alpha = 0.5) + geom_smooth(aes(light_avg, medincome), se = FALSE, size = 0.5) + geom_smooth(aes(light_avg, medincome), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10() + scale_y_log10(labels = scales::label_number_si()) + labs(title = &quot;log_medincome by log_light_avg&quot;, y = &quot;medincome (log10 scale)&quot;, x = &quot;light_avg (log10 scale)&quot;) Figure 2.7: log_medincome by log_light_avg (all states) d_df %&gt;% ggplot(aes(light_avg, medincome)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_y_continuous(labels = scales::label_number_si()) + # scale_y_log10() + facet_wrap(~state)+ labs(title = &quot;light_avg by medincome&quot;) Figure 2.8: medincome by light_avg (faceted by state) d_df %&gt;% ggplot(aes(light_avg, medincome)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10() + scale_y_log10(labels = scales::label_number_si()) + facet_wrap(~state)+ labs(title = &quot;log_medincome by log_light_avg&quot;, y = &quot;medincome (log10 scale)&quot;, x = &quot;light_avg (log10 scale)&quot;) Figure 2.9: log_medincome by log_light_avg (faceted by state) pop_density and medincome are correlated (corr = 0.35) but less so for states with big urban areas (especially VA). Since they are correlated, and my goal is to check whether we can associate radiance levels with a demographic change, it’s best if I include only one models. Since pop_density ~ light_avg (corr = 0.94) has less variance than pop_density ~ light_avg (corr = 0.37). 2.2.2 Radiance distribution by state Each pixel has a light radiance value. A plot of the empirical cumulative distribution function (Figure 2.10 shows that the distributions are similar in shape. The most noticeable difference is that the portion of zero values (completely black pixels) differs by state. county_light_sf %&gt;% mutate(state = fct_reorder(state, value, median)) %&gt;% ggplot(aes(value, color = state)) + stat_ecdf(geom = &quot;line&quot;, pad = FALSE, size = 0.5, alpha = 0.6) + scale_x_log10() + scale_y_continuous(label = percent_format()) + labs(title = &quot;Radiance ECDF&quot;, x = &quot;light value (log10 scale)&quot;, y = &quot;&quot;) Figure 2.10: Radiance empirical cumulative density 2000 The unusual shape of the density plot (Figure 2.11) shows each state has a lot of pixels with zero values, then almost no pixels with values less than about 5 (this is a log scale), then a large portion with values in approximately the 6-30 range. county_light_sf %&gt;% mutate(value = value + 1e-6, state = fct_reorder(state, value, median)) %&gt;% ggplot(aes(value, color = state)) + geom_density(size = 0.5) + scale_x_log10() + labs(title = &quot;Radiance density&quot;, x = &quot;light value (log10 scale)&quot;, y = &quot;&quot;) Figure 2.11: Radiance density 2000 2.2.3 \\(R^2\\) and linear relationships: slope estimates by state models_nested &lt;- d_df %&gt;% mutate(log_light_avg = log10(light_avg), log_pop_density = log10(pop_density)) %&gt;% select(state, log_pop_density, log_light_avg) %&gt;% group_by(state) %&gt;% nest() %&gt;% mutate(model = map(data, function(df) lm(log_pop_density ~ log_light_avg, data = df)), tidied = map(model, tidy), augmented = map(model, broom::augment), glanced = map(model, broom::glance) ) models &lt;- left_join(tidied &lt;- models_nested %&gt;% unnest(c(state, tidied)), adj_r_sqr &lt;- models_nested %&gt;% unnest(c(state, glanced)) %&gt;% select(state, adj.r.squared, sigma), by = &quot;state&quot; ) %&gt;% filter(!term == &quot;(Intercept)&quot;) %&gt;% select(state, term, estimate, estimate_std.error = std.error, adj.r.squared, adj.r.squared_sigma = sigma) %&gt;% arrange(desc(adj.r.squared)) state_levels &lt;- rev(models$state) models %&gt;% pivot_longer(cols = c(estimate, adj.r.squared), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% mutate(state = factor(state, levels = state_levels)) %&gt;% ggplot(aes(value, state)) + geom_point() + expand_limits(x = 0) + facet_wrap(~ metric, scales = &quot;free_x&quot;, nrow = 1) + labs(title = &quot;R^2 and estimated slope of\\nlm(log_pop_density ~ log_light_avg)&quot;) Figure 2.12: R-squared and estimated slope of lm(log_light_avg ~ log_pop_density) 2.2.4 EDA summary comments The relationship between \\(log_{10}(pop\\_density)\\) and \\(log_{10}(light\\_avg)\\) in figures 2.4 and 2.5 isn’t quite linear, and there are differences by state. So I expect simple linear models to perform worse than more sophisticated ones. Nonetheless, I want to see how good linear models are, since they are simple and inexpensive. "],["modeling-and-model-comparison.html", "3 Modeling and model comparison 3.1 Train and test on training data set 3.2 Assessing model performance with the holdout data set 3.3 Comparing 2000 and 2010", " 3 Modeling and model comparison As noted in the EDA section: The relationship between \\(log_{10}(pop\\_density)\\) and \\(log_{10}(light\\_avg)\\) in figures 2.4 and 2.5) isn’t quite linear, and there are differences by state. So I expect simple linear models to perform worse than more sophisticated ones. Nonetheless, I want to see how good linear models are, since they are simple and inexpensive. In this section I do the following: Prepare train-test and holdout data sets Build (and where necessary, train) some models, then compare them using performance metrics Test the best performing models against the holdout data set. I use the following performance metrics: Concordance correlation coefficient (ccc) according the help for yardstick::ccc() “is a metric of both consistency/correlation and accuracy,” R-Squared. I use yardstick::rsq() which according to the documentation “is simply the squared correlation between truth and estimate … [that] guarantees a value on \\((0,1)\\).” I use metrics that are scale-free, since I want the freedom to use models with different transformations of the data. The principle metric is ccc. # For 2000 data_df &lt;- tar_read(all_df) %&gt;% #fix NAs mutate(atotal = if_else(!is.na(atotal), atotal, calc_area), pop_density_official = if_else(!is.na(pop_density_official), pop_density_official, pop_density)) %&gt;% # drop a small number of data errors/artifacts filter(light_avg &gt; 1e-5) # prepare data for train-test and holdout d_df &lt;- data_df %&gt;% # dplyr::select(state:pop_density_official) %&gt;% # avoid zero values mutate(log_light_avg = log10(light_avg + 1e-6), log_pop_density = log10(pop_density + 1e-6), log_pop_density_official = log10(pop_density_official + 1e-6)) %&gt;% select(state, county, light_avg, log_light_avg, pop_density, log_pop_density, pop_density_official, log_pop_density_official) # following https://cran.r-project.org/web/packages/rsample/vignettes/Working_with_rsets.html set.seed(123) main_split = initial_split(d_df, strata = c(&quot;state&quot;)) train_split &lt;- analysis(main_split) holdout &lt;- assessment(main_split) light_folds &lt;- vfold_cv(train_split, v = n_folds, repeats = 1) # For 2010 data_df_c &lt;- tar_read(all_df_c) %&gt;% #fix NAs mutate(atotal = if_else(!is.na(atotal), atotal, calc_area), pop_density_official = if_else(!is.na(pop_density_official), pop_density_official, pop_density)) %&gt;% # drop a small number of data errors/artifacts filter(light_avg &gt; 1e-5) # prepare data for train-test and holdout assess_df &lt;- data_df_c %&gt;% # dplyr::select(state:pop_density_official) %&gt;% # avoid zero values mutate(log_light_avg = log10(light_avg + 1e-6), log_pop_density = log10(pop_density + 1e-6), log_pop_density_official = log10(pop_density_official + 1e-6)) %&gt;% select(state, county, light_avg, log_light_avg, pop_density, log_pop_density, pop_density_official, log_pop_density_official) set.seed(2021) # inspiration/source: Dave Robinson&#39;s coding videos; see https://github.com/dgrtwo/data-screencasts prep_juice &lt;- function(x) juice(prep(x)) mset &lt;- metric_set(rsq, ccc) # use scale-free metrics (not rmse) grid_control &lt;- control_grid(save_pred = TRUE, save_workflow = TRUE, extract = extract_model) augment.workflow &lt;- function(x, newdata, ...) { predict(x, newdata, ...) %&gt;% bind_cols(newdata) } predict_on_holdout &lt;- function(workflow, tbl_train, tbl_test) { workflow %&gt;% fit(tbl_train) %&gt;% augment(tbl_test) } # for use in fit_resamples() keep_pred &lt;- control_resamples(save_pred = TRUE, save_workflow = TRUE) 3.1 Train and test on training data set 3.1.1 lin1: pop_density ~ light_avg Let’s start simple. In lin1 the data is concentrated in smaller radiance values, and the model is depressing the slope of the line due to outliers at high pop_density. lm_model &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% set_mode(&quot;regression&quot;) my_formula &lt;- &quot;pop_density ~ light_avg&quot; lin_rec &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula)) lin1_wf &lt;- workflow() %&gt;% add_recipe(lin_rec) %&gt;% add_model(lm_model) lin1_res &lt;- lin1_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lin1_metric_summary &lt;- lin1_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;lin1: {my_formula}&quot;)) %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lin1_metric_summary[[1, 1]]} = {round(lin1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lin1_metric_summary[[2, 1]]} = {round(lin1_metric_summary[[2, 2]], 3)}&quot;) lin1_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = pop_density, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + labs(title = glue(&quot;{lin1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted pop_density: {metric_summary_for_plot}&quot;) ) Figure 3.1: lin1: Simplest linear model 3.1.2 lin2: pop_density_official ~ light_avg Should I use official area values from the US Census Bureau to calculate population density instead of area values calculated based on the county boundaries? In a word: no. Using official area values, rsq and ccc are slightly lower than lin 1 (figure 3.1), perhaps because pop_density is calculated using the same boundaries I’m using to determine which light pixels are part of each county, and therefore I’m dealing with similar error in both. I use the area values I calculated in all other models. my_formula &lt;- &quot;pop_density_official ~ light_avg&quot; lin_rec2 &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula)) lin2_wf &lt;- workflow() %&gt;% add_recipe(lin_rec2) %&gt;% add_model(lm_model) # defined above lin2_res &lt;- lin2_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lin2_metric_summary &lt;- lin2_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;lin2: {my_formula}&quot;)) %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lin2_metric_summary[[1, 1]]} = {round(lin2_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lin2_metric_summary[[2, 1]]} = {round(lin2_metric_summary[[2, 2]], 3)}&quot;) lin2_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = pop_density_official, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + labs(title = glue(&quot;{lin2_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted pop_density_official: {metric_summary_for_plot}&quot;) ) Figure 3.2: lin2: Using official area values to calculate population density 3.1.3 lin3: log_pop_density ~ log_light_avg With both predictor and response on a log scale, performance metrics are better. Compare with lin1 in Figure 3.1. my_formula &lt;- &quot;log_pop_density ~ log_light_avg&quot; lin_rec3 &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula)) lin3_wf &lt;- workflow() %&gt;% add_recipe(lin_rec3) %&gt;% add_model(lm_model) # defined above lin3_res &lt;- lin3_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lin3_metric_summary &lt;- lin3_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;lin3: {my_formula}&quot;)) %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lin3_metric_summary[[1, 1]]} = {round(lin3_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lin3_metric_summary[[2, 1]]} = {round(lin3_metric_summary[[2, 2]], 3)}&quot;) lin3_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = log_pop_density, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + # coord_obs_pred() + labs(title = glue(&quot;{lin3_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: {metric_summary_for_plot}&quot;) ) Figure 3.3: lin3: Simplest linear model with log10 transformations 3.1.4 pol1: log_light_avg ~ poly(log_pop_density, 2) Since the data in Figure 2.4 looks like it has close to a quadratic relationship (a convex curve), let’s try a second order polynomial. Performance is quite good. my_formula_basic &lt;- &quot;log_pop_density ~ log_light_avg&quot; my_formula &lt;- &quot;log_pop_density ~ poly(log_light_avg, 2)&quot; pol1_rec &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula_basic)) %&gt;% step_poly(log_light_avg, degree = 2) pol1_wf &lt;- workflow() %&gt;% add_recipe(pol1_rec) %&gt;% add_model(lm_model) # defined above pol1_res &lt;- pol1_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) pol1_metric_summary &lt;- pol1_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;pol1: {my_formula}&quot;)) %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{pol1_metric_summary[[1, 1]]} = {round(pol1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {pol1_metric_summary[[2, 1]]} = {round(pol1_metric_summary[[2, 2]], 3)}&quot;) pol1_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = log_pop_density, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + labs(title = glue(&quot;{pol1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: {metric_summary_for_plot}&quot;) ) Figure 3.4: pol1: Linear model with second order polynomial 3.1.5 lme1: multi-level model with lme4::lmer Since states differ in the range and distribution of radiance values, are there improvements if I use a fixed effects model “log_pop_density ~ log_light_avg + (log_light_avg | state)?” Unfortunately not. There is no meaningful improvement over Figure 3.3. Apparently state doesn’t hold enough unique information to be helpful. lme_model &lt;- linear_reg() %&gt;% set_engine(&quot;lmer&quot;) %&gt;% set_mode(&quot;regression&quot;) my_formula &lt;- &quot;log_pop_density ~ log_light_avg + (log_light_avg | state)&quot; lme1_wf &lt;- workflow() %&gt;% add_variables(outcomes = log_pop_density, predictors = c(log_light_avg, state) ) %&gt;% add_model( lme_model, formula = as.formula(my_formula) ) lme1_res &lt;- lme1_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lme1_metric_summary &lt;- lme1_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;lme1: {my_formula}&quot;)) %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lme1_metric_summary[[1, 1]]} = {round(lme1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lme1_metric_summary[[2, 1]]} = {round(lme1_metric_summary[[2, 2]], 3)}&quot;) lme1_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = log_pop_density, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + theme(plot.title = element_text(size = 14)) + labs(title = glue(&quot;{lme1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: {metric_summary_for_plot}&quot;) ) Figure 3.5: lme1: Multi-level model using ‘state’ 3.1.6 bs1: linear model with b-spline Since lin3 (figure 3.3) seems to be overestimating high and low radiance, let’s try a spline. First I tune the model to determine how many knots to include in the spline: bs_rec &lt;- recipe(log_pop_density ~ log_light_avg, data = analysis(light_folds$splits[[1]])) %&gt;% step_ns(log_light_avg, deg_free = tune(&quot;log_light_avg&quot;)) bs_model &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% set_mode(&quot;regression&quot;) my_formula = &quot;log_pop_density ~ bs(log_light_avg)&quot; bs1_wf &lt;- workflow() %&gt;% add_recipe(bs_rec) %&gt;% add_model(bs_model) k_grid &lt;- tibble(log_light_avg = 1:6) bs_tune &lt;- bs1_wf %&gt;% tune_grid(resamples = light_folds, grid = k_grid, metrics = mset, control = grid_control) autoplot(bs_tune) + labs(title = &quot;Tuning bs1&quot;) Figure 3.6: Tuning bs1 I’ll use 2 knots, which maximizes both ccc and rsq. bs_wf_best &lt;- bs1_wf %&gt;% finalize_workflow(select_best(bs_tune, metric = &quot;ccc&quot;)) select_best(bs_tune, metric = &quot;ccc&quot;) %&gt;% gt() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #jepsfgfnlx .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #jepsfgfnlx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #jepsfgfnlx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #jepsfgfnlx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #jepsfgfnlx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jepsfgfnlx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #jepsfgfnlx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #jepsfgfnlx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #jepsfgfnlx .gt_column_spanner_outer:first-child { padding-left: 0; } #jepsfgfnlx .gt_column_spanner_outer:last-child { padding-right: 0; } #jepsfgfnlx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #jepsfgfnlx .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #jepsfgfnlx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #jepsfgfnlx .gt_from_md > :first-child { margin-top: 0; } #jepsfgfnlx .gt_from_md > :last-child { margin-bottom: 0; } #jepsfgfnlx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #jepsfgfnlx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #jepsfgfnlx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #jepsfgfnlx .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #jepsfgfnlx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #jepsfgfnlx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #jepsfgfnlx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #jepsfgfnlx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jepsfgfnlx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #jepsfgfnlx .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #jepsfgfnlx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #jepsfgfnlx .gt_sourcenote { font-size: 90%; padding: 4px; } #jepsfgfnlx .gt_left { text-align: left; } #jepsfgfnlx .gt_center { text-align: center; } #jepsfgfnlx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #jepsfgfnlx .gt_font_normal { font-weight: normal; } #jepsfgfnlx .gt_font_bold { font-weight: bold; } #jepsfgfnlx .gt_font_italic { font-style: italic; } #jepsfgfnlx .gt_super { font-size: 65%; } #jepsfgfnlx .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } log_light_avg .config 2 Preprocessor2_Model1 Both ccc and rsq are slightly better than lin3, and the high and low predictions are not consistently overestimated: bs1_res &lt;- bs_wf_best %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) bs1_metric_summary &lt;- bs1_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;bs1: {my_formula}&quot;)) %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{bs1_metric_summary[[1, 1]]} = {round(bs1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {bs1_metric_summary[[2, 1]]} = {round(bs1_metric_summary[[2, 2]], 3)}&quot;) bs1_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = log_pop_density, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + theme(plot.title = element_text(size = 14)) + labs(title = glue(&quot;{bs1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: {metric_summary_for_plot}&quot;) ) Figure 3.7: bs1: Linear model with B-spline to capture curvature 3.1.7 XGBoost: log_pop_density ~ log_light_avg + state Now a non-linear model and one that needs training: boosted trees using XGBoost. In this model state categories are dummy variables. set.seed(2021) xg1_rec &lt;- recipe(log_pop_density ~ log_light_avg + state, data = analysis(light_folds$splits[[1]])) %&gt;% step_dummy(state) xg1_wf &lt;- workflow() %&gt;% add_recipe(xg1_rec) %&gt;% add_model(boost_tree(mode = &quot;regression&quot;, mtry = tune(), trees = tune(), # tree_depth = , # default is 6 learn_rate = .01) %&gt;% set_engine(&quot;xgboost&quot;)) xg1_tune &lt;- xg1_wf %&gt;% tune_grid(light_folds, grid = crossing(mtry = c(2, 5, 8, 11), trees = seq(50, 400, 50), #threshold = c(0.01) # default is 0.01 ), metrics = mset, control = grid_control) Tuning the model: results suggest using between 250 and 400 trees with nearly equal performance including 5, 8 or 11 variables at each split: autoplot(xg1_tune) + labs(title = &quot;Tuning xg1&quot;) Figure 3.8: Tuning xg1 The best fit includes 400 trees and using \\(mtry = 8\\) to randomly sample 8 variables at each split (which is nearly all of them in this case). The benefit of 400 trees versus 300 is very small, and given we have ~650 data points for training (before considering that we are cross-validating with 10 folds), I use the lesser number. Fewer trees reduces the chance of overfitting. xg1_wf_best &lt;- xg1_wf %&gt;% finalize_workflow(select_best(xg1_tune, metric = &quot;ccc&quot;)) %&gt;% update_model(boost_tree(mode = &quot;regression&quot;, mtry = 8, trees = 300, # tree_depth = 3, learn_rate = .01) %&gt;% set_engine(&quot;xgboost&quot;)) So I use these: print(xg1_wf_best) ## ══ Workflow ═════════════════════════════════════════════════════════════════════ ## Preprocessor: Recipe ## Model: boost_tree() ## ## ── Preprocessor ───────────────────────────────────────────────────────────────── ## 1 Recipe Step ## ## • step_dummy() ## ## ── Model ──────────────────────────────────────────────────────────────────────── ## Boosted Tree Model Specification (regression) ## ## Main Arguments: ## mtry = 8 ## trees = 300 ## learn_rate = 0.01 ## ## Computational engine: xgboost Summary metrics are good, however the model is underestimating most radiance values: my_formula &lt;- &quot;log_pop_density ~ log_light_avg + state&quot; xg1_fit_best &lt;- xg1_wf_best %&gt;% fit(train_split) xg1_res &lt;- xg1_fit_best %&gt;% last_fit(main_split, metrics = mset) xg1_metric_summary &lt;- xg1_res %&gt;% collect_metrics() %&gt;% mutate(model = glue(&quot;xg1: {my_formula}&quot;)) %&gt;% mutate(n = n_folds, std_err = NA_real_) %&gt;% dplyr::select(.metric, .estimate, n, std_err, model) metric_summary_for_plot &lt;- glue(&quot;{xg1_metric_summary[[2, 1]]} = {round(xg1_metric_summary[[2, 2]], 3)}&quot;, &quot;; {xg1_metric_summary[[1, 1]]} = {round(xg1_metric_summary[[1, 2]], 3)}&quot;) xg1_res %&gt;% collect_predictions() %&gt;% ggplot(aes(x = log_pop_density, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + theme(plot.title = element_text(size = 14)) + labs(title = glue(&quot;{xg1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: {metric_summary_for_plot}&quot;) ) Figure 3.9: xg1: Random forest with boosted graidient descent 3.1.8 Summary of train-test results As expected, the highest-performing model is not the simplest. lin1 and lin2 are the two worst-performing models; I exclude them from the next stage. The others (simpler and more complex) perform similarly. all_metrics &lt;- bind_rows( lin1_metric_summary, lin2_metric_summary, lin3_metric_summary, pol1_metric_summary, xg1_metric_summary, lme1_metric_summary, bs1_metric_summary, NULL ) %&gt;% filter(.metric %in% c(&quot;ccc&quot;, &quot;rsq&quot;)) model_levels = all_metrics %&gt;% filter(.metric == &quot;ccc&quot;) %&gt;% arrange(.estimate) %&gt;% pull(model) all_metrics %&gt;% mutate(model = factor(model, levels = model_levels)) %&gt;% ggplot(aes(.estimate, model)) + geom_errorbarh(aes(xmax = .estimate + std_err, xmin = .estimate - std_err), height = 0.2) + geom_point() + expand_limits(x = 1.0) + facet_wrap( ~ .metric, nrow = 1) + theme(plot.title.position = &quot;plot&quot;) + labs(title = glue(&quot;Comparing model performance for metrics &quot;, &quot;{glue_collapse(sort(unique(all_metrics$.metric)), sep = &#39;, &#39;)}&quot;), subtitle = &quot;Performance on train-test set&quot;, x = &quot;mean metric estimate across all folds; error bars +/- std_err&quot;) Figure 3.10: Summary of train-test results all_metrics %&gt;% arrange(.metric, desc(.estimate)) %&gt;% gt() %&gt;% tab_header( title = md(&quot;**Model evaluation on train-test data set**&quot;) ) %&gt;% fmt_number(columns = c(.estimate, std_err), decimals = 3) %&gt;% fmt_missing(columns = everything(), missing_text = &quot;---&quot;) %&gt;% cols_align(columns = model, align = &quot;left&quot;) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #bdilrftxzn .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #bdilrftxzn .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #bdilrftxzn .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #bdilrftxzn .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #bdilrftxzn .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #bdilrftxzn .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #bdilrftxzn .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #bdilrftxzn .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #bdilrftxzn .gt_column_spanner_outer:first-child { padding-left: 0; } #bdilrftxzn .gt_column_spanner_outer:last-child { padding-right: 0; } #bdilrftxzn .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #bdilrftxzn .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #bdilrftxzn .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #bdilrftxzn .gt_from_md > :first-child { margin-top: 0; } #bdilrftxzn .gt_from_md > :last-child { margin-bottom: 0; } #bdilrftxzn .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #bdilrftxzn .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #bdilrftxzn .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #bdilrftxzn .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #bdilrftxzn .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #bdilrftxzn .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #bdilrftxzn .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #bdilrftxzn .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #bdilrftxzn .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #bdilrftxzn .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #bdilrftxzn .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #bdilrftxzn .gt_sourcenote { font-size: 90%; padding: 4px; } #bdilrftxzn .gt_left { text-align: left; } #bdilrftxzn .gt_center { text-align: center; } #bdilrftxzn .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #bdilrftxzn .gt_font_normal { font-weight: normal; } #bdilrftxzn .gt_font_bold { font-weight: bold; } #bdilrftxzn .gt_font_italic { font-style: italic; } #bdilrftxzn .gt_super { font-size: 65%; } #bdilrftxzn .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Model evaluation on train-test data set .metric .estimate n std_err model ccc 0.966 10 &mdash; xg1: log_pop_density ~ log_light_avg + state ccc 0.953 10 0.004 bs1: log_pop_density ~ bs(log_light_avg) ccc 0.953 10 0.004 pol1: log_pop_density ~ poly(log_light_avg, 2) ccc 0.948 10 0.004 lme1: log_pop_density ~ log_light_avg + (log_light_avg | state) ccc 0.947 10 0.005 lin3: log_pop_density ~ log_light_avg ccc 0.917 10 0.009 lin1: pop_density ~ light_avg ccc 0.893 10 0.024 lin2: pop_density_official ~ light_avg rsq 0.955 10 &mdash; xg1: log_pop_density ~ log_light_avg + state rsq 0.942 10 0.008 bs1: log_pop_density ~ bs(log_light_avg) rsq 0.942 10 0.008 pol1: log_pop_density ~ poly(log_light_avg, 2) rsq 0.931 10 0.008 lin3: log_pop_density ~ log_light_avg rsq 0.931 10 0.008 lme1: log_pop_density ~ log_light_avg + (log_light_avg | state) rsq 0.931 10 0.020 lin1: pop_density ~ light_avg rsq 0.922 10 0.022 lin2: pop_density_official ~ light_avg 3.2 Assessing model performance with the holdout data set In this section I use data the models haven’t seen yet from 2000 (the holdout data set). lin3 summary metrics are quite good, however again the curvature in the data is visible in the way the model is overestimating high and low radiance values: lin3_pred &lt;- lin3_wf %&gt;% predict_on_holdout(., train_split, holdout) lin3_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_pop_density, estimate = .pred), ccc(lin3_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(lin3_metric_summary$model)) lin3_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{lin3_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{lin3_metric_summary[[2, 1]]} = {round(lin3_metric_summary[[2, 3]], 3)}&quot;, &quot;; {lin3_metric_summary[[1, 1]]} = {round(lin3_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.11: lin3 using holdout set pol1 looks good but is slightly overestimating high radiance values: pol1_pred &lt;- pol1_wf %&gt;% predict_on_holdout(., train_split, holdout) pol1_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_pop_density, estimate = .pred), ccc(lin3_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(pol1_metric_summary$model)) pol1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{pol1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{pol1_metric_summary[[2, 1]]} = {round(pol1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {pol1_metric_summary[[1, 1]]} = {round(pol1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.12: pol1 using holdout set Again lme1 fails to do better than lin3: # error=TRUE to continue execution in case model fails to converge lme1_pred &lt;- lme1_wf %&gt;% predict_on_holdout(., train_split, holdout) lme1_metric_summary &lt;- bind_rows( rsq(lme1_pred, truth = log_pop_density, estimate = .pred), ccc(lme1_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(lme1_metric_summary$model)) lme1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{lme1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{lme1_metric_summary[[2, 1]]} = {round(lme1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {lme1_metric_summary[[1, 1]]} = {round(lme1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.13: lme1 using holdout set Again bs1 is performing quite well: bs1_pred &lt;- bs_wf_best %&gt;% predict_on_holdout(., train_split, holdout) bs1_metric_summary &lt;- bind_rows( rsq(bs1_pred, truth = log_pop_density, estimate = .pred), ccc(bs1_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(bs1_metric_summary$model)) bs1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{bs1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{bs1_metric_summary[[2, 1]]} = {round(bs1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {bs1_metric_summary[[1, 1]]} = {round(bs1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.14: bs1 using holdout set xg1 performance metrics are good, but the model is again systematically underestimating: xg1_pred &lt;- xg1_fit_best %&gt;% predict_on_holdout(., train_split, holdout) xg1_metric_summary &lt;- bind_rows( rsq(xg1_pred, truth = log_pop_density, estimate = .pred), ccc(xg1_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(xg1_metric_summary$model)) xg1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{xg1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{xg1_metric_summary[[2, 1]]} = {round(xg1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {xg1_metric_summary[[1, 1]]} = {round(xg1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.15: xg1 using holdout set 3.2.1 Summary: model evaluation using holdout data set Results are similar for all models. The very simple lin3 is very competitive. I exclude lme1 from the next stage. all_metrics &lt;- bind_rows( lin3_metric_summary, pol1_metric_summary, lme1_metric_summary, bs1_metric_summary, xg1_metric_summary ) model_levels = all_metrics %&gt;% filter(.metric == &quot;ccc&quot;) %&gt;% arrange(.estimate) %&gt;% pull(model) all_metrics %&gt;% mutate(model = factor(model, levels = model_levels)) %&gt;% ggplot(aes(.estimate, model)) + geom_point() + geom_label(aes(label = str_pad(round(.estimate, 3), width = 5, side = &quot;right&quot;, pad = &quot;0&quot;) ), size = 3, nudge_x = -0.1, hjust = 1) + expand_limits(x = 0) + facet_wrap(~ .metric, scales = &quot;free_x&quot;) + theme(legend.position = &quot;none&quot;, plot.title.position = &quot;plot&quot;) + labs(title = &quot;Model evaluation on holdout data set&quot;, x = &quot;metric estimate&quot;, y = &quot;&quot;) Figure 3.16: Summary of holdout results all_metrics %&gt;% dplyr::select(-.estimator) %&gt;% arrange(.metric, desc(.estimate)) %&gt;% gt() %&gt;% tab_header( title = md(&quot;**Model evaluation on holdout data set**&quot;) ) %&gt;% fmt_number(columns = .estimate, decimals = 3) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #cynmmmtmhg .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #cynmmmtmhg .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #cynmmmtmhg .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #cynmmmtmhg .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #cynmmmtmhg .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #cynmmmtmhg .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #cynmmmtmhg .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #cynmmmtmhg .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #cynmmmtmhg .gt_column_spanner_outer:first-child { padding-left: 0; } #cynmmmtmhg .gt_column_spanner_outer:last-child { padding-right: 0; } #cynmmmtmhg .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #cynmmmtmhg .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #cynmmmtmhg .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #cynmmmtmhg .gt_from_md > :first-child { margin-top: 0; } #cynmmmtmhg .gt_from_md > :last-child { margin-bottom: 0; } #cynmmmtmhg .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #cynmmmtmhg .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #cynmmmtmhg .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #cynmmmtmhg .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #cynmmmtmhg .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #cynmmmtmhg .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #cynmmmtmhg .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #cynmmmtmhg .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #cynmmmtmhg .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #cynmmmtmhg .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #cynmmmtmhg .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #cynmmmtmhg .gt_sourcenote { font-size: 90%; padding: 4px; } #cynmmmtmhg .gt_left { text-align: left; } #cynmmmtmhg .gt_center { text-align: center; } #cynmmmtmhg .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #cynmmmtmhg .gt_font_normal { font-weight: normal; } #cynmmmtmhg .gt_font_bold { font-weight: bold; } #cynmmmtmhg .gt_font_italic { font-style: italic; } #cynmmmtmhg .gt_super { font-size: 65%; } #cynmmmtmhg .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Model evaluation on holdout data set .metric .estimate model ccc 0.972 bs1: log_pop_density ~ bs(log_light_avg) ccc 0.966 xg1: log_pop_density ~ log_light_avg + state ccc 0.963 lin3: log_pop_density ~ log_light_avg ccc 0.963 pol1: log_pop_density ~ poly(log_light_avg, 2) ccc 0.963 lme1: log_pop_density ~ log_light_avg + (log_light_avg | state) rsq 0.955 xg1: log_pop_density ~ log_light_avg + state rsq 0.954 bs1: log_pop_density ~ bs(log_light_avg) rsq 0.937 lme1: log_pop_density ~ log_light_avg + (log_light_avg | state) rsq 0.937 lin3: log_pop_density ~ log_light_avg rsq 0.937 pol1: log_pop_density ~ poly(log_light_avg, 2) 3.3 Comparing 2000 and 2010 I use the four remaining models to predict changes in log_pop_density in 2010 based on average county radiance log_light_avg in the same year, comparing performance on the holdout set with the 2010 assessment set. lin3 looks pretty good, but the model overestimates high 2010 log_pop_density values. lin3_pred &lt;- lin3_wf %&gt;% predict_on_holdout(., holdout, assess_df) lin3_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_pop_density, estimate = .pred), ccc(lin3_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(lin3_metric_summary$model)) lin3_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{lin3_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{lin3_metric_summary[[2, 1]]} = {round(lin3_metric_summary[[2, 3]], 3)}&quot;, &quot;; {lin3_metric_summary[[1, 1]]} = {round(lin3_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.17: lin3 2010 assess set results pol1 is underestimating low 2010 log_pop_density values and overestimating most other values: pol1_pred &lt;- pol1_wf %&gt;% predict_on_holdout(., holdout, assess_df) pol1_metric_summary &lt;- bind_rows( rsq(pol1_pred, truth = log_pop_density, estimate = .pred), ccc(pol1_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(pol1_metric_summary$model)) pol1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{pol1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{pol1_metric_summary[[2, 1]]} = {round(pol1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {pol1_metric_summary[[1, 1]]} = {round(pol1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.18: pol1 2010 assess set results Like pol1, bs1 is underestimating low 2010 log_pop_density values and overestimating most other values: bs1_pred &lt;- bs_wf_best %&gt;% predict_on_holdout(., holdout, assess_df) bs1_metric_summary &lt;- bind_rows( rsq(bs1_pred, truth = log_pop_density, estimate = .pred), ccc(bs1_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(bs1_metric_summary$model)) bs1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{bs1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{bs1_metric_summary[[2, 1]]} = {round(bs1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {bs1_metric_summary[[1, 1]]} = {round(bs1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.19: bs1 2010 assess set results xg1 is underestimating low and high log_pop_density values: xg1_pred &lt;- xg1_fit_best %&gt;% predict_on_holdout(., holdout, assess_df) xg1_metric_summary &lt;- bind_rows( rsq(xg1_pred, truth = log_pop_density, estimate = .pred), ccc(xg1_pred, truth = log_pop_density, estimate = .pred) ) %&gt;% mutate(model = unique(xg1_metric_summary$model)) xg1_pred %&gt;% ggplot(aes(log_pop_density, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{xg1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted log_pop_density: &quot;, &quot;{xg1_metric_summary[[2, 1]]} = {round(xg1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {xg1_metric_summary[[1, 1]]} = {round(xg1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.20: xg1 2010 assess set results 3.3.1 Summary: model performance on census 2010 data. The simplest model lin3 perform slightly better, and our next-simplest odes. pol1, and bs1 are essentially equal. xg1 does worse at high and low log_pop_density values. This is a sign that xg1 may be overfitted on the training data. Even so, the difference in performance among the models are quite small. Looking the absolute value of difference in means between predicted and true log_pop_density, I see all four models are performing similarly: all_means &lt;- bind_rows( with(lin3_pred, t.test(.pred, log_pop_density, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(lin3_metric_summary$model)), with(xg1_pred, t.test(.pred, log_pop_density, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(xg1_metric_summary$model)), with(pol1_pred, t.test(.pred, log_pop_density, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(pol1_metric_summary$model)), with(bs1_pred, t.test(.pred, log_pop_density, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(bs1_metric_summary$model)) ) %&gt;% rename(diff_in_means = estimate) %&gt;% arrange(desc(abs(diff_in_means))) %&gt;% mutate(model = as_factor(model)) # creates levels with current ordering all_means %&gt;% ggplot(aes(abs(diff_in_means), model)) + geom_errorbarh(aes(xmin = abs(conf.low), xmax = abs(conf.high), height = 0.1)) + geom_point() + theme(legend.position = &quot;none&quot;, plot.title.position = &quot;plot&quot;) + labs(title = &quot;Difference in means between predicted and\\nactual log_pop_density (2010 data)&quot;, subtitle = &quot;T-test at 95% CI.&quot;, x = &quot;difference in means&quot;, y = &quot;&quot;) Figure 3.21: Differences in the means (predicted v actual) all_metrics &lt;- bind_rows( lin3_metric_summary, pol1_metric_summary, xg1_metric_summary, bs1_metric_summary ) model_levels = all_metrics %&gt;% filter(.metric == &quot;ccc&quot;) %&gt;% arrange(.estimate) %&gt;% pull(model) all_metrics %&gt;% mutate(model = factor(model, levels = model_levels)) %&gt;% ggplot(aes(.estimate, model)) + geom_point() + geom_label(aes(label = str_pad(round(.estimate, 3), width = 5, side = &quot;right&quot;, pad = &quot;0&quot;) ), size = 3, nudge_x = -0.1, hjust = 1) + expand_limits(x = 0) + facet_wrap(~ .metric, scales = &quot;free_x&quot;) + theme(legend.position = &quot;none&quot;, plot.title.position = &quot;plot&quot;) + labs(title = &quot;Model evaluation on 2010 data&quot;, x = &quot;metric estimate&quot;, y = &quot;&quot;) Figure 3.22: Holdout set results all_metrics %&gt;% dplyr::select(-.estimator) %&gt;% arrange(.metric, desc(.estimate)) %&gt;% gt() %&gt;% tab_header( title = md(&quot;**Model evaluation on 2010 data**&quot;) ) %&gt;% fmt_number(columns = c(.estimate), decimals = 3) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #whozyloehn .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #whozyloehn .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #whozyloehn .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #whozyloehn .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #whozyloehn .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #whozyloehn .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #whozyloehn .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #whozyloehn .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #whozyloehn .gt_column_spanner_outer:first-child { padding-left: 0; } #whozyloehn .gt_column_spanner_outer:last-child { padding-right: 0; } #whozyloehn .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #whozyloehn .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #whozyloehn .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #whozyloehn .gt_from_md > :first-child { margin-top: 0; } #whozyloehn .gt_from_md > :last-child { margin-bottom: 0; } #whozyloehn .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #whozyloehn .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #whozyloehn .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #whozyloehn .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #whozyloehn .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #whozyloehn .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #whozyloehn .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #whozyloehn .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #whozyloehn .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #whozyloehn .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #whozyloehn .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #whozyloehn .gt_sourcenote { font-size: 90%; padding: 4px; } #whozyloehn .gt_left { text-align: left; } #whozyloehn .gt_center { text-align: center; } #whozyloehn .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #whozyloehn .gt_font_normal { font-weight: normal; } #whozyloehn .gt_font_bold { font-weight: bold; } #whozyloehn .gt_font_italic { font-style: italic; } #whozyloehn .gt_super { font-size: 65%; } #whozyloehn .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Model evaluation on 2010 data .metric .estimate model ccc 0.967 lin3: log_pop_density ~ log_light_avg ccc 0.957 pol1: log_pop_density ~ poly(log_light_avg, 2) ccc 0.957 bs1: log_pop_density ~ bs(log_light_avg) ccc 0.953 xg1: log_pop_density ~ log_light_avg + state rsq 0.945 lin3: log_pop_density ~ log_light_avg rsq 0.927 bs1: log_pop_density ~ bs(log_light_avg) rsq 0.926 pol1: log_pop_density ~ poly(log_light_avg, 2) rsq 0.915 xg1: log_pop_density ~ log_light_avg + state "],["interpreting-the-results.html", "4 Interpreting the results 4.1 How much did the population density and radiance change between 2000 and 2010? 4.2 Conclusion", " 4 Interpreting the results As noted in the last section: The simpler models do better: lin3, pol1, and bs1 are essentially equal in performance while xg1 does worse and underestimates most radiance values. Let’s look closer at how population density and radiance levels changed between 2000 and 2010. d_df &lt;- tar_read(all_df) %&gt;% # drop a small number of data errors/artifacts filter(light_avg &gt; 1e-5) %&gt;% select(state, county, light_avg, log_light_avg, pop, calc_area, pop_density, log_pop_density) pop_density_2000_mean &lt;- sum(d_df$pop) / sum(d_df$calc_area) # summary of all states of interest (avoiding averages of averages) pop_density_2000_median &lt;- median(d_df$pop / d_df$calc_area) light_2000 &lt;- tar_read(light_sf) d_df_c &lt;- tar_read(all_df_c) %&gt;% # drop a small number of data errors/artifacts filter(light_avg &gt; 1e-5) %&gt;% select(state, county, light_avg, log_light_avg, pop, calc_area, pop_density, log_pop_density) pop_density_2010_mean &lt;- sum(d_df_c$pop) / sum(d_df_c$calc_area) # summary of all states of interest (avoiding averages of averages) pop_density_2010_median &lt;- median(d_df_c$pop / d_df_c$calc_area) light_2010 &lt;- tar_read(light_sf_c) 4.1 How much did the population density and radiance change between 2000 and 2010? census_compare &lt;- d_df %&gt;% select(state, county, light_avg_2000 = light_avg, pop_density_2000 = pop_density, log_light_avg_2000 = log_light_avg, log_pop_density_2000 = log_pop_density) %&gt;% left_join(., d_df_c %&gt;% select(state, county, light_avg_2010 = light_avg, pop_density_2010 = pop_density, log_light_avg_2010 = log_light_avg, log_pop_density_2010 = log_pop_density ), by = c(&quot;state&quot;, &quot;county&quot;)) %&gt;% mutate(light_diff = light_avg_2010 - light_avg_2000, pop_density_diff = pop_density_2010 - pop_density_2000, pct_light_diff = light_avg_2010 / light_avg_2000 - 1, pct_pop_density_diff = pop_density_2010 / pop_density_2000 - 1) %&gt;% na.omit() census_compare_long &lt;- census_compare %&gt;% pivot_longer(cols = contains(c(&quot;2000&quot;, &quot;2010&quot;, &quot;diff&quot;)), names_to = &quot;metric&quot;, values_to = &quot;values&quot;) 4.1.1 From 2000 to 2010 radiance increased almost twice as much as population density County population density is up by ~13% overall in the states of interest, and median population density is up by 8.5%. Over the same time interval county average light radiance is up by a whopping 23%. What could account for such significant change in radiance? I see three main possibilities: Perhaps the result is real, and I’m missing confounding influences (U_pe and U_er in Figure 1.1). For example, in 2010 the country was early in recovery from the Great Recession, and interest rates (and bond financing for construction projects) were very low. Did this spark a building boom that increased radiance values? Perhaps I should consider the business cycle or other representation of relative economic activity. Perhaps the radiance levels have a lot of error in them, the intercalibration coefficients don’t do enough to allow valid multi-year comparisons, or there are other anomalies or influences (U_rad). Perhaps I made errors along the way. mean_summary &lt;- tribble( ~variable, ~mean_2000, ~mean_2010, ~median_2000, ~median_2010, &quot;light_avg&quot;, mean(light_2000$value), mean(light_2010$value), median(light_2000$value), median(light_2010$value), &quot;pop_density&quot;, pop_density_2000_mean, pop_density_2010_mean, pop_density_2000_median, pop_density_2010_median ) %&gt;% mutate(pct_diff_mean = mean_2010 / mean_2000 - 1, pct_diff_median = median_2010 / median_2000 - 1) mean_summary %&gt;% gt() %&gt;% tab_header( title = md(&quot;**County population density km^2 in 2000 and 2010**&quot;) ) %&gt;% fmt_number(columns = starts_with(c(&quot;mean&quot;, &quot;median&quot;)), decimals = 1) %&gt;% fmt_percent(columns = contains(&quot;diff&quot;), decimals = 1) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #osncjrvket .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #osncjrvket .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #osncjrvket .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #osncjrvket .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #osncjrvket .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #osncjrvket .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #osncjrvket .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #osncjrvket .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #osncjrvket .gt_column_spanner_outer:first-child { padding-left: 0; } #osncjrvket .gt_column_spanner_outer:last-child { padding-right: 0; } #osncjrvket .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #osncjrvket .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #osncjrvket .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #osncjrvket .gt_from_md > :first-child { margin-top: 0; } #osncjrvket .gt_from_md > :last-child { margin-bottom: 0; } #osncjrvket .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #osncjrvket .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #osncjrvket .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #osncjrvket .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #osncjrvket .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #osncjrvket .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #osncjrvket .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #osncjrvket .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #osncjrvket .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #osncjrvket .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #osncjrvket .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #osncjrvket .gt_sourcenote { font-size: 90%; padding: 4px; } #osncjrvket .gt_left { text-align: left; } #osncjrvket .gt_center { text-align: center; } #osncjrvket .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #osncjrvket .gt_font_normal { font-weight: normal; } #osncjrvket .gt_font_bold { font-weight: bold; } #osncjrvket .gt_font_italic { font-style: italic; } #osncjrvket .gt_super { font-size: 65%; } #osncjrvket .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } County population density km^2 in 2000 and 2010 variable mean_2000 mean_2010 median_2000 median_2010 pct_diff_mean pct_diff_median light_avg 14.2 17.5 7.9 8.6 23.0&percnt; 8.3&percnt; pop_density 46.0 52.0 24.0 26.1 13.1&percnt; 8.5&percnt; data_for_plot &lt;- bind_rows( census_compare %&gt;% select(log_light_avg = log_light_avg_2000, log_pop_density = log_pop_density_2000) %&gt;% mutate(year = &quot;2000&quot;), census_compare %&gt;% select(log_light_avg = log_light_avg_2010, log_pop_density = log_pop_density_2010) %&gt;% mutate(year = &quot;2010&quot;), ) p1 &lt;- data_for_plot %&gt;% ggplot() + geom_smooth(aes(log_light_avg, log_pop_density, color = year), se = FALSE) + scale_color_viridis_d(end = 0.9) + annotate(&quot;rect&quot;, xmin = 0.25, xmax = 1.2, ymin = 0.25, ymax = 1.5, alpha = .2) + labs(title = &quot;Comparing log_pop_density ~ log_light_avg&quot;, subtitle = &quot;Loess&quot;) p2 &lt;- data_for_plot %&gt;% ggplot() + geom_smooth(aes(log_light_avg, log_pop_density, color = year), method = &quot;lm&quot;, se = FALSE) + scale_color_viridis_d(end = 0.9) + annotate(&quot;rect&quot;, xmin = 0.25, xmax = 1.2, ymin = 0.25, ymax = 1.5, alpha = .2) + labs(subtitle = &quot;Linear&quot;) A shift in the underlying distributions is changing the regression lines. (p1 + p2) + plot_layout(guides = &#39;collect&#39;) + theme(plot.margin = unit(c(10, 0, 5, 0), &quot;mm&quot;)) Figure 4.1: Comparing regression lines in 2000 and 2010 (loess and linear) 4.1.2 Exploring changes in radiance and population density 2000 and 2010 The following density plots indicate a large portion of low-density counties lost population (a continuation of rural counties hollowing out) with growth happening in relatively few counties. An even smaller portion of the counties had increased radiance in 2010. census_compare_long %&gt;% filter(str_detect(metric, &quot;pct&quot;)) %&gt;% ggplot(aes(x = values, y = metric, color = metric, fill = metric)) + geom_density_ridges(rel_min_height = 0.005, alpha = 0.4) + scale_x_continuous(labels = percent_format(accuracy = 1)) + scale_color_viridis_d(end = 0.8) + scale_fill_viridis_d(end = 0.8) + labs(title = &quot;Percentage difference - density plot&quot;, subtitle = &quot;Values: 2010 / 2000 - 1&quot;) Figure 4.2: Percentage difference in population density and radiance 2000 and 2010 Compared to 2000, the radiance values from 2010 are not as concentrated. There are more counties at the lowest radiance levels, and at radiance values larger than the mode, the density curve shifts right. census_compare_long %&gt;% filter(metric %in% c(&quot;light_avg_2000&quot;, &quot;light_avg_2010&quot;)) %&gt;% ggplot(aes(x = values, color = metric, fill = metric)) + geom_density(alpha = 0.4) + scale_x_log10(labels = label_number_si()) + scale_color_viridis_d(end = 0.8) + scale_fill_viridis_d(end = 0.8) + labs(title = &quot;County light radiance &quot;, subtitle = &quot;2010 and 2000 census values&quot;, x = &quot;values (log10 scale)&quot;) Figure 4.3: County average radiance 2000 and 2010 Looking at population density values rather than percentage differences (figure 4.2), in 2010 I see a small shift to more counties being in the range 30-400 per sq km (37 - 154 per sq mi) range. census_compare_long %&gt;% filter(metric %in% c(&quot;pop_density_2000&quot;, &quot;pop_density_2010&quot;)) %&gt;% ggplot(aes(x = values, color = metric, fill = metric)) + geom_density(alpha = 0.3) + scale_x_log10(labels = label_number_si()) + scale_color_viridis_d(end = 0.8) + scale_fill_viridis_d(end = 0.8) + labs(title = &quot;Country population density&quot;, subtitle = &quot;2010 and 2000 census values&quot;, x = &quot;values (log10 scale)&quot;) Figure 4.4: County population density 2000 and 2010 Looking at percent changes in population density 2000 to 2010 with pop_density_2000 on the x-axis, I see similar trends in each state: census_compare %&gt;% ggplot(aes(x = pop_density_2000, y = pct_pop_density_diff, color = state)) + geom_point(alpha = 0.15) + geom_smooth(se = FALSE, size = 0.5) + scale_x_log10() + scale_y_continuous(labels = percent_format()) + expand_limits(y = c(-0.5, 1.0)) + labs(title = glue(&quot;Which counties had the biggest changes\\nin population density?&quot;), subtitle = &quot;2000 to 2010&quot;, x = &quot;pop_density_2000 (log scale)&quot; ) Figure 4.5: Changes in population density 2000-2010 Below a radiance value of about 30, the percent difference in radiance between 2000 and 2010 seems nearly linear; above 30 there is little or no relationship. census_compare %&gt;% ggplot(aes(x = light_avg_2000, y = pct_light_diff, color = state)) + geom_point(alpha = 0.15) + geom_smooth(se = FALSE, size = 0.5) + scale_x_log10() + scale_y_continuous(labels = percent_format()) + labs(title = glue(&quot;Which counties had the biggest changes\\nin avg radiance?&quot;), subtitle = &quot;2000 to 2010&quot;, x = &quot;light_avg_2000 (log scale)&quot; ) Figure 4.6: Changes in radiance 2000-2010 Looking at the relationship between pct_pop_density_diff and pct_light_diff, once again I see the highest and lowest radiance values are remarkably less linear in relationship than the great majority of the values, which lay between them. census_compare %&gt;% ggplot(aes(pct_light_diff, pct_pop_density_diff, color = pop_density_2000, size = pop_density_2000)) + geom_point(alpha = 0.25) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = percent_format()) + scale_y_continuous(labels = percent_format()) + scale_color_gradient2(low = &quot;black&quot;, mid = &quot;green&quot;, high = &quot;orange&quot;, midpoint = log10(pop_density_2000_median), trans=log10_trans()) + guides(size = &quot;none&quot;) + labs(title = glue(&quot;pct_pop_density_diff by pct_light_diff&quot;), subtitle = &quot;2000 to 2010&quot; ) Figure 4.7: Comparing the percent difference in county radiance with percent difference in county population density (2000 to 2010 4.2 Conclusion Since the underlying distributions shifted between 2000 and 2010, I am not surprised that xg1, the model most sensitive to the training data, performs worse on the 2010 data. I trained bs1 on 2000 data as well, however its spline knot parameter holds much less information and thus is less sensitive. If I were attempting original research or directing civil or governmental investments using the techniques employed here, how would I know the underlying distributions changed (or more specifically: changed enough to affect the accuracy of some of my models)? I would look for changes in the distribution of the data I could gather, then likely use an ensemble of models to make predictions. "],["end-notes.html", "5 End notes 5.1 Acknowlegements 5.2 Data provenance 5.3 Assumptions and limitations 5.4 Project organization", " 5 End notes 5.1 Acknowlegements Image and data processing by Earth Observation Group, Payne Institute for Public Policy, Colorado School of Mines. DMSP data collected by US Air Force Weather Agency. Special thanks to … Daynan Crull, Trevor Monroe and the world bank for their Open Night Lights tutorial, presented as part of the 3rd Annual Geo4Dev Symposium &amp; Workshop December 10-11, 2020. Robin Lovelace, Jakub Nowosad, and Jannes Muenchow for the very helpful Geocomputation with R, which is now available as a physical book from CRC Press. Edzer Pebesma and all those who have been working on sf and terra in recent years. July 2021 overview: https://edzer.github.io/UseR2021/#1 Kyle Walker, Matt Herman, and Kris Eberwein for the tidycensus package The RStudio team and other contributors to the tidyverse and tidymodels package families. Max Kuhn and Julia Silge for Tidy Modeling with R. I used Version 0.0.1.9010 (2021-07-19). CRAN maintainers and the R Foundation for fostering a high-quality, growing R ecosystem. 5.2 Data provenance 5.2.1 Version 4 DMSP-OLS Nighttime Lights Time Series From https://eogdata.mines.edu/products/dmsp/ Since the 1970s, the U.S. Air Force Defense Meteorological Satellite Program (DMSP) has operated satellite sensors capable of detecting the visible and near-infrared (VNIR) emissions from cities and towns. The DMSP Operational Linescan System (OLS) acquires global daytime and nighttime imagery of the Earth in two spectral bands (VIS and TIR). The nighttime “VIS” bandpass straddles the VNIR portion of the spectrum (0.5 to 0.9 um). The VIS band signal is intensified at night using a photomultiplier tube (PMT), making it possible to detect faint VNIR emission sources. The PMT system was implemented for the detection of clouds at night. An unanticipated consequence of the nighttime light intensification is the detection of city lights, gas flares, and fires. Since 1997, EOG had been pioneering in combining the imagery taken by DMSP-OLS to produce global Nighttime Light maps. With annual data stretch from 1992 to 2013, making DMSP Nighttime Light the longest data series available for nocturnal remote sensing on human activities. From https://eogdata.mines.edu/dmsp/downloadV4composites.html The files are cloud-free composites made using all the available archived DMSP-OLS smooth resolution data for calendar years. In cases where two satellites were collecting data - two composites were produced. The products are 30 arc second grids, spanning -180 to 180 degrees longitude and -65 to 75 degrees latitude. Citations: These data sets are the results of years of algorithm development and production efforts. The data are here for you and others to use in any way you like and have no copyright. Please acknowledge our efforts by including a brief data source attribution and one or more of the following references in anything you write where our data is utilized. Data source attribution “Earth Observation Group, Colorado School of Mines.” References: Elvidge, C. D., Baugh, K. E., Kihn, E. A., Kroehl, H. W., &amp; Davis, E. R. (1997). Mapping city lights with nighttime data from the DMSP Operational Linescan System. Photogrammetric Engineering and Remote Sensing, 63(6), 727-734. Baugh, K., Elvidge, C. D., Ghosh, T., &amp; Ziskin, D. (2010). Development of a 2009 stable lights product using DMSP-OLS data. Proceedings of the Asia-Pacific Advanced Network, 30(0), 114. 5.2.2 Radiance data I use Radiance Calibrated values(Hsu et al. 2015), a transformation of the Digital Number (DN) made available by the EOG group at https://eogdata.mines.edu/products/dmsp/#v4_dmsp_download From https://eogdata.mines.edu/products/dmsp/#radcal : The Operational Linescan System (OLS) flown on the Defense Meteorological Satellite Program (DMSP) satellites, has a unique capability to record low light imaging data at night worldwide. These data are archived at the National Oceanic and Atmospheric Administration (NOAA) National Geophysical Data Center (NGDC). The useful data record stretches back to 1992 and is ongoing. The OLS visible band detector observes radiances about one million times dimmer than most other Earth observing satellites. The sensor is typically operated in a high gain setting to enable the detection of moonlit clouds. However, with six bit quantization and limited dynamic range, the recorded data are saturated in the bright cores of urban centers. A limited set of observations have been obtained at low lunar illumination were obtained where the gain of the detector was set significantly lower than its typical operational setting (sometimes by a factor of 100). By combining these sparse data acquired at low gain settings with the operational data acquired at high gain settings, we have produced a set of global nighttime lights product with no sensor saturation. This product can be related to radiances based on the pre-flights sensor calibration. See the Global Radiance Calibrated Nighttime Lights Product Readme for a summary of the methodology. These files align with the US decennial census, which has the highest-quality demographic data. I downloaded the image files on 2021-07-17. F12-F15_20000103-20001229_rad_v4.geotiff.tgz (F12-F15_20000103-20001229_rad_v4); using F12-F15_20000103-20001229_rad_v4.avg_vis.tif F16_20100111-20110731_rad_v4.geotiff.tgz (F16_20100111-20110731_rad_v4); using F16_20100111-20110731_rad_v4.avg_vis.tif 5.2.3 Intercalibration https://eogdata.mines.edu/products/dmsp/ I use the EOG’s Radiance Calibrated products, which have data for the years I want and requires intersatellite and inter-annual calibration in order to make valid comparisons. The coefficient table is available in DMSP-OLS Radiance Calibrated Nighttime Lights Time Series with Intercalibration(Hsu et al. 2015): The Defense Meteorological Satellite Program-Operational Linescan System (DMSP-OLS) stable lights products are made using operational OLS data collected at high gain settings, resulting in sensor saturation on brightly lit areas, such as city centers. This has been a paramount shortcoming of the DMSP-OLS stable lights time series. This study outlines a methodology that greatly expands the dynamic range of the OLS data using observations made at different fixed-gain settings, and by incorporating the areas not affected by saturation from the stable lights product. The radiances for the fixed-gain data are computed based on each OLS sensor’s pre-flight calibration. The result is a product known as the OLS radiance calibrated nighttime lights. A total of eight global datasets have been produced, representing years from 1996 to 2010. To further facilitate the usefulness of these data for time-series analyses, corrections have been made to counter the sensitivity differences of the sensors, and coefficients are provided to adjust the datasets to allow inter-comparison. page 1868 includes the relevant coefficients, as does the Global Radiance Calibrated Nighttime Lights Product Readme: Inter-satellite Calibration Multiplier. Satellite Base Gain (dB) Multiplier Radiance @ DN1 (W/cm2/sr) F14 55 0.82 1.23E-10 F16 55 1.0 1.50E-10 Note all [radiance] products are inter-satellite calibrated to the base gain setting of 55 dB of satellite F16. (page 1872) Thus, to perform inter-satellite calibration, I multiplied the radiance values in the F14 GeoTIFF image by 0.82. While this improves the comparability in time series, it contributes its own sources of error, as summarized below. I take the Inter-annual Calibration Coefficients directly from the Global Radiance Calibrated Nighttime Lights Product Readme: NOTE: (1) This table is preliminary, and needs to be updated. (2) There is no data for &quot;F16_20051128-20061224_rad_v4&quot; for it being the reference dataset. (3) F16_20100111-20101209_rad_v4 and F16_20100111-20110731_rad_v4 share the same data for there is onyl small diferrence from adding images from year 2011. Equation Y=Coeff0+Coeff1*X Y-File F16_20051128-20061224_rad_v4 X-File Pow Coeff0 Coeff1 R2 N_Pt F12_19960316-19970212_rad_v4 1 4.336 0.915 0.971 20540 F12_19990119-19991211_rad_v4 1 1.423 0.780 0.980 20846 F12-F15_20000103-20001229_rad_v4 1 3.658 0.710 0.980 20866 &lt;- F14-F15_20021230-20031127_rad_v4 1 3.736 0.797 0.980 20733 F14_20040118-20041216_rad_v4 1 1.062 0.761 0.984 20844 F16_20100111-20101209_rad_v4 1 2.196 1.195 0.981 20848 &lt;- F16_20100111-20110731_rad_v4 1 -1.987 1.246 0.981 20848 Thus to make values comparable across years, I further transform the 2000 radiance values: \\[Y=Coeff_0+Coeff_1 * X = 3.658 + 0.710 * X\\] where X is the vector of radiance values. Similarly for 2010: \\[Y=Coeff_0+Coeff_1 * X = 2.196 + 1.195 * X\\] Note the \\(R^2\\) values above. This adjustment is introducing error. 5.3 Assumptions and limitations 5.3.1 Limitations 5.3.1.1 Limitations in nighttime lights data The World Bank’s Open Nighttime Lights tutorial (WorldBank 2020) summarizes the following limitations (among others): 2.2.2. Limitations and challenges of DMSP-OLS Low radiometric resolution (6-bit data, values range from 0-63) No on-board calibration Large spatial resolution (4.9km for nighttime VIS band) Saturation in urban cores These limitations can lead to challenges for scientists using these data for their work. For example, drawing conclusions from the DMSP-OLS stable lights series may be challenging in low-density urban areas …. In addition, the extent and intensity of lit areas cannot directly delimit urban regions due to the “blooming” effect. Therefore I use the Radiance Calibrated products. Note however that they are not absolute radiance(Hsu et al. 2015) Many users would like to relate the DN values in the Radiance Calibrated products to actual radiance. The fixed-gain image avoids the automatic gain variation by VDGA which is not recorded in the data stream. So theoretically, by applying the preflight sensor calibration, the actual radiance could be derived from the DN. Nevertheless, even under such controlled operation, there is no means to address the degradation of the equipment without an on board calibration device. Moreover, the uncertainty brought by blending Stable Light products, which were taken under variable gain settings, make it even more unlikely to derive the exact radiance from the Radiance Calibrated product. As a result, it is suggested that the Radiance Calibrated product is only suitable for analyses which do not require actual radiance. Nevertheless, the conversion factor from DN to radiance for the Radiance Calibrated products is listed in Table 3 for reference. Note all products are inter-satellite calibrated to the base gain setting of 55 dB of satellite F16. (page 1872) and Because the DMSP-OLS does not carry an on-board calibration device for the visible band, it is not possible to track how actual radiance is being converted to DN even if the auto-adjust gain setting is fixed. Instead we rely on the preflight calibration made for each OLS instrument prior to launch. Therefore, even though the Radiance Calibrated products are made from data collected under much more controlled setting than the Stable Lights products, the radiance values should still be considered relative and not absolute. (page 1874) In this analysis I refer to these Radiance Calibrated values as “radiance” and “radiance values” 5.3.1.2 Limitations in intercalibration As summarized in (Hsu et al. 2015) Being freed from the saturation problem, Radiance Calibrated products need a reference area which not only is stable enough but also provides samples with brightness ranging from very low light to the world’s highest levels. Los Angeles was taken as the reference for the Radiance Calibrated products for two reasons. First, Los Angeles has long been a mature metropolis and the light change is negligible. Second, being a metropolis, it can provide samples with high DNs from the city center, as well as low DNs from the suburban area. While the distribution of light data from L.A. over the time period may have been relatively stable, the differences probably weren’t zero, and the error or bias is not quantified. In fact the readme includes the following related to inter-annual calibration: This table is preliminary, and needs to be updated. The readme includes the following: Date: 01/15/2015 Modified: 09/09/2020 Typical uncertainty of sensors noted in (Chander et al. 2013): In general, the absolute radiometric calibration for most optical sensors is specified to an uncertainty of 5%; hence, the likely uncertainty (in reflectance units) on a measured reflectance value of, for example, 0.4 will be ±5% of 0.4 equal to ±0.02. (page 1058) Scene Variability can source of error, however in this case, use of light averaged over data collected at various times throughout the year minimizes this source of error. The intercalibration of satellite instruments often requires comparing observations from different instruments coincident in space, time, and viewing geometry. As these are never exactly aligned, thresholds are usually applied to define the collocations. The choice of these thresholds directly impacts the uncertainty of the comparison, partially due to the scene variability within the range of the collocation criteria. The collocation criteria represent tradeoffs between the errors on each collocation and the number of collocations available. Collocated observations from a pair of satellite instruments are not sampled at exactly the same place or time. Variations in the atmosphere and surface during the interval between their observations introduce errors when comparing their collocated radiances. The greater the collocated observations interval, the larger the contribution of the scene’s variability to the total error budget. (page 1061) 5.3.2 Census data and state and county geometry This analysis used three sources of data: US census 2000, which provided total population by county and median income by county. US census 2010, which provided total population by county. This decennial census did not provide median household income (in fact, the 2010 census did away with the “long form” that provided the data for the sf3 table). I initially used the five-year ACS (2006-2010), which provided total population by county and median income by county, however once I decided not to use median income, I didn’t need the ACS. Which is good since ACS population estimates are ~2% lower than the 2010 census for the counties I examined in this analysis, and I did not need to deal with differences in methodology between the decennial census and ACS, or adjust for inflation. The tidycensus package provides the population data from 2000 and 2010 decennial censuses. Median income per family comes from the decennial 2000 census and the American Community Survey (ACS) five-year estimates 2006-2010 provided by the US Census Bureau. tidycensus also provides state and county geometry via the tigris package (and corresponding extracts from the Census Bureau’s Master Address File/Topologically Integrated Geographic Encoding and Referencing (TIGER) database). 5.3.3 Population and population density I used these county boundaries to calculate the area of each county and (combined with decennial census population), each county’s population density. I included land and water area when calculating total area, since my calculation of average light radiance per county used the same boundaries that included land and water within those boundaries I did not do anything to adjust for light blooming beyond whatever the EOG did in their Radiance Calibrated products. Instead I assume blooming artifacts are similar in the 2000 and 2010 products. On the coasts and in other high-traffic areas, census population (and therefore population density) may not capture vacationers and other itinerant people that contribute to population density, the capacity of the build environment, and (if my causal conjecture holds), the degree to which an area is built up and generated light. I assume any effect due to itinerant people is small enough (or consistent across the time interval) that it can be ignored. 5.3.4 Economic development / GDP / business cycle The US was in the middle of the Great Recession in 2010. Could this be a factor in the lower radiance levels that year compared to 2000? Starting in 2008, the recession depressed new investments, including building projects that would have created more nighttime light. This may have contributed to slower growth in radiance, however it’s unlikely to have caused light levels in 2010 to be lower than 2000. Consider: shopping malls and hotels may have had lower occupancy and fewer customers, but they would have left the lights on in their parking lots. 5.4 Project organization 5.4.1 Data preparation pipeline implemented to with targets package I used the targets package to define a pipeline for data preparation. Dependencies among the set of functions are specified in the _targets file and executed via tar_make(). They include the following: tar_manifest() %&gt;% arrange(name) %&gt;% gt() ## here() starts at /Users/dmoul/rwork/nightlight html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #yyichzgjis .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #yyichzgjis .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yyichzgjis .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #yyichzgjis .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #yyichzgjis .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yyichzgjis .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yyichzgjis .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #yyichzgjis .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #yyichzgjis .gt_column_spanner_outer:first-child { padding-left: 0; } #yyichzgjis .gt_column_spanner_outer:last-child { padding-right: 0; } #yyichzgjis .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #yyichzgjis .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #yyichzgjis .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #yyichzgjis .gt_from_md > :first-child { margin-top: 0; } #yyichzgjis .gt_from_md > :last-child { margin-bottom: 0; } #yyichzgjis .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #yyichzgjis .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #yyichzgjis .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yyichzgjis .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #yyichzgjis .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yyichzgjis .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #yyichzgjis .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #yyichzgjis .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yyichzgjis .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yyichzgjis .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #yyichzgjis .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yyichzgjis .gt_sourcenote { font-size: 90%; padding: 4px; } #yyichzgjis .gt_left { text-align: left; } #yyichzgjis .gt_center { text-align: center; } #yyichzgjis .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #yyichzgjis .gt_font_normal { font-weight: normal; } #yyichzgjis .gt_font_bold { font-weight: bold; } #yyichzgjis .gt_font_italic { font-style: italic; } #yyichzgjis .gt_super { font-size: 65%; } #yyichzgjis .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } name command pattern all_df model_prepare_data(county_sf) NA all_df_c model_prepare_data(county_sf_c) NA bbox_vec get_bbox(census_df, these_states) NA census_df get_census_data(all_states, census_year_a, \"census\") NA census_df_c get_census_data(all_states, census_year_c, \"census\") NA census_focus_df census_focus(census_df, these_states, bbox_vec) NA census_focus_df_c census_focus(census_df_c, these_states, bbox_vec) NA county_sf get_county_light_sf(census_focus_df, light_sf) NA county_sf_c get_county_light_sf(census_focus_df_c, light_sf_c) NA light_points_df get_light_levels(bbox_vec, source_light_file_2000, \\n intersat_calibration = 0.82, interannual_calibration = c(3.658, \\n 0.71)) NA light_points_df_c get_light_levels(bbox_vec, source_light_file_2010, \\n intersat_calibration = 1, interannual_calibration = c(2.196, \\n 1.195)) NA light_sf get_light_sf(light_points_df, state_boundaries_geom) NA light_sf_c get_light_sf(light_points_df_c, state_boundaries_geom) NA state_boundaries_geom state_boundaries(census_focus_df) NA tar_visnetwork() draws a dependency graph. Zoom in to see the labels on the nodes: tar_visnetwork() ## here() starts at /Users/dmoul/rwork/nightlight 5.4.2 Session information sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] splines stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] gt_0.3.1 multilevelmod_0.0.0.9000 yardstick_0.0.8 ## [4] workflowsets_0.1.0 workflows_0.2.3 tune_0.1.6 ## [7] rsample_0.1.0 recipes_0.1.16 parsnip_0.1.7 ## [10] modeldata_0.1.1 infer_1.0.0 dials_0.0.9 ## [13] broom_0.7.9 tidymodels_0.1.3 hrbrthemes_0.8.6 ## [16] scales_1.1.1 units_0.7-2 tidycensus_1.0 ## [19] patchwork_1.1.1 ggdag_0.2.3 dagitty_0.3-1 ## [22] ggridges_0.5.3 terra_1.3-22 sf_1.0-2 ## [25] glue_1.4.2 forcats_0.5.1 stringr_1.4.0 ## [28] dplyr_1.0.7 purrr_0.3.4 readr_2.0.1 ## [31] tidyr_1.1.3 tibble_3.1.4 ggplot2_3.3.5 ## [34] tidyverse_1.3.1 targets_0.7.0 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.3.1 uuid_0.1-4 backports_1.2.1 systemfonts_1.0.2 ## [5] plyr_1.8.6 igraph_1.2.6 sp_1.4-5 listenv_0.8.0 ## [9] digest_0.6.27 foreach_1.5.1 htmltools_0.5.2 fansi_0.5.0 ## [13] checkmate_2.0.0 magrittr_2.0.1 doParallel_1.0.16 tzdb_0.1.2 ## [17] globals_0.14.0 modelr_0.1.8 gower_0.2.2 extrafont_0.17 ## [21] extrafontdb_1.0 hardhat_0.1.6 colorspace_2.0-2 rvest_1.0.1 ## [25] rappdirs_0.3.3 haven_2.4.3 xfun_0.25 rgdal_1.5-23 ## [29] callr_3.7.0 crayon_1.4.1 jsonlite_1.7.2 iterators_1.0.13 ## [33] survival_3.2-13 tigris_1.4.1 gtable_0.3.0 ipred_0.9-11 ## [37] V8_3.4.2 Rttf2pt1_1.3.9 DBI_1.1.1 Rcpp_1.0.7 ## [41] GPfit_1.0-8 foreign_0.8-81 proxy_0.4-26 lava_1.6.9 ## [45] prodlim_2019.11.13 htmlwidgets_1.5.3 httr_1.4.2 ellipsis_0.3.2 ## [49] pkgconfig_2.0.3 nnet_7.3-16 sass_0.4.0 dbplyr_2.1.1 ## [53] utf8_1.2.2 here_1.0.1 tidyselect_1.1.1 rlang_0.4.11 ## [57] DiceDesign_1.9 visNetwork_2.0.9 munsell_0.5.0 cellranger_1.1.0 ## [61] tools_4.1.0 cli_3.0.1 generics_0.1.0 evaluate_0.14 ## [65] fastmap_1.1.0 yaml_2.2.1 processx_3.5.2 knitr_1.33 ## [69] fs_1.5.0 tidygraph_1.2.0 future_1.22.1 xml2_1.3.2 ## [73] compiler_4.1.0 rstudioapi_0.13 curl_4.3.2 e1071_1.7-8 ## [77] reprex_2.0.1 lhs_1.1.1 bslib_0.2.5.1 stringi_1.7.4 ## [81] ps_1.6.0 gdtools_0.2.3 lattice_0.20-44 Matrix_1.3-4 ## [85] classInt_0.4-3 vctrs_0.3.8 pillar_1.6.2 lifecycle_1.0.0 ## [89] furrr_0.2.3 jquerylib_0.1.4 data.table_1.14.0 maptools_1.1-1 ## [93] raster_3.4-13 R6_2.5.1 bookdown_0.23 KernSmooth_2.23-20 ## [97] parallelly_1.27.0 codetools_0.2-18 boot_1.3-28 MASS_7.3-54 ## [101] assertthat_0.2.1 rprojroot_2.0.2 withr_2.4.2 parallel_4.1.0 ## [105] hms_1.1.0 grid_4.1.0 rpart_4.1-15 timeDate_3043.102 ## [109] class_7.3-19 rmarkdown_2.10 pROC_1.17.0.1 lubridate_1.7.10 References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
