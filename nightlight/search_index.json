[["introduction.html", "Exploring Nighttime lights in the U.S. Southeast Model specification and evaluation in the tidymodels framework 1 Introduction 1.1 Questions 1.2 Method 1.3 Causal assumptions", " Exploring Nighttime lights in the U.S. Southeast Model specification and evaluation in the tidymodels framework Daniel Moul 2021-08-29 1 Introduction Nighttime lights are an indicator of human presence and have been used for analyzing economic trends in GDP, population, electricity consumption, \\(CO_2\\) emissions, and other dimensions of human activity and organization(Proville 2017). The Earth Observation Group (EOG), now at the Colorado School of Mines, makes available average nighttime light products covering much of the world, derived from data collected by the Defense Meteorological Satellite Program’s primary instrument, the Operational Linescan System (DMPS-OLS), employing Visible and Near-Infrared (VNIR) band sensors(Elvidge 1997). Data from this satellite series was collected 1992-2013. DMSP satellites are in sun-synchronized polar orbit at approximately 458 nautical miles(“FACT SHEET: Defense Meteorological Satellite Program” 2003). DMSP Satellite image source: NOAA 1.1 Questions Using the EOG’s average radiance products(Hsu et al. 2015) for my part of the world: With what accuracy can I associate average night radiance values with human presence? Using the models identified in (1), how well can I predict the same dimension(s) of human presence 10 years later? 1.2 Method Use data in the form of GeoTIFF files from the Nighttime Lights time series The files are cloud-free composites made using all the available archived DMSP-OLS smooth resolution data for calendar years. In cases where two satellites were collecting data - two composites were produced. The products are 30 arc second grids, spanning -180 to 180 degrees longitude and -65 to 75 degrees latitude. Specifically I will use Radiance Calibrated values rather than Digital Number (DN) values. See Radiance data and Intercalibration. Limit my focus to the southeastern states of the USA (where I live) and census data from the years 2000 and 2010. As indicators of “human presence” I use data from the US Census Bureau: (A) demographic information (population and median income) and (B) geographic information (legal state and county borders from the TIGER/Line Shapefiles database), all retrieved using the tidycensus and tigris R packages. Associate each pixel (radiance value) in the GeoTIFF image with a county based on its position within county borders and calculate average light level per county. Similarly, calculate county land area based on county borders. Explore models with linear and non-linear associations among county-level demographic data and county average light levels, including transformations of the demographic data to improve linear relationships. Partition the data into two sets: (1) train-test set and (2) a holdout set for final model evaluation. Using the best model(s) identified in the prior step, evaluate model performance on 2010 census data and compare with census 2000, using the EOG’s intercalibration coefficients to enable valid, multi-year comparisons of radiance levels. 1.3 Causal assumptions In this endeavor, causal relationships are largely unknown and may be highly confounded. Unknown colliders may have large effects. I use only one or two predictor variables, and given the subject matter, face more than the usual limitations of observational studies. dag &lt;- dagitty( &#39;dag{ rad [response, pos=&quot;1,0&quot;] pop [exposure, pos=&quot;3,0&quot;] env [response, pos=&quot;2,0&quot;] U_env [unobserved, pos=&quot;2,1&quot;] U_rad [unobserved, pos=&quot;1,1&quot;] U_pop [unobserved, pos=&quot;3,1&quot;] U_pe [unobserved, pos=&quot;2.5,-0.5&quot;] U_er [unobserved, pos=&quot;1.5,-0.5&quot;] U_env -&gt; env rad &lt;- env &lt;- pop U_pop -&gt; pop U_rad -&gt; rad pop -&gt; U_pe -&gt; env env -&gt; U_er -&gt; rad }&#39;) ggdag(dag) + theme(panel.grid.major = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank()) + labs(title = &quot;Proposed causal graph&quot;, x = NULL, y = NULL) Figure 1.1: Causal graph: there are many confounders and colliders My conjecture is that greater population density (pop) creates a larger, denser built environment (env) which in turn creates more nightlight (rad). Likely there are unobserved influences (confounders) and sources of error on the measured nightlight (U_rad), including some related to the satellites’ sensors and EOG’s algorithms for determining average nightlight values, radiance values, and intercalibration coefficients. There are many unobserved confounders on population density, including economic conditions, economic growth in various sectors, geography, and zoning laws. Additionally, some of these influences may not have remained constant between 2000 and 2010. There likely are unknown colliders (U_pe and U_er) that mediate the influence of population density on the built environment and the built environment on radiance. I assume the effect of U_rad is much smaller than U_env, U_c, and U_er. In this case U_pop is not relevant, and similarly, I ignore any influences that mediate changes in population that might change the association between population changes and population density changes. Given all the above, and the fact that I am building models for a relatively small geographic area and with only one year’s data (and then comparing to only one other year’s data), I do not expect highly accurate predictions. References "],["exploratory-data-analysis.html", "2 Exploratory data analysis 2.1 Map 2.2 Data for modeling", " 2 Exploratory data analysis c_focus &lt;- tar_read(census_focus_df) county_boundaries_terra &lt;- as(tar_read(census_focus_df),&quot;Spatial&quot;) state_boundaries_terra &lt;- as(tar_read(state_boundaries_geom),&quot;Spatial&quot;) state_list &lt;- glue_collapse(sort(unique(c_focus$state)), sep = &#39;, &#39;, last = &quot; and &quot;) 2.1 Map Specifically, I look at the 859 counties in 9 states: AL, GA, KY, MS, NC, SC, TN, VA and WV. It’s interesting to note that in nearly every county there is one main spot of light. Typically this city or town is the county seat of government and locus of economic activity. Radiance values span a wider range than this visible image suggests. # following the pattern at https://rspatial.org/terra/rs/2-exploration.html f1 &lt;- rast(source_light_file_2000) my_bbox &lt;- tar_read(bbox_vec) e &lt;- ext(as.numeric(c(my_bbox$xmin, my_bbox$xmax, my_bbox$ymin, my_bbox$ymax))) f2 &lt;- crop(f1, e) plotRGB(f2, r = 1, g = 1, b = 1, scale = 255, stretch = &quot;lin&quot;) plot(county_boundaries_terra, border = &quot;#fffdd0&quot;, lwd = 0.25, add = TRUE) # cream color plot(state_boundaries_terra, border = &quot;#fffdd0&quot;, add = TRUE) # cream color Figure 2.1: Average nightlight in the S.E. United States in 2000 2.2 Data for modeling # models_df &lt;- tar_read(models) data_df &lt;- tar_read(all_df) %&gt;% #fix NAs mutate(atotal = if_else(!is.na(atotal), atotal, calc_area), pop_density_official = if_else(!is.na(pop_density_official), pop_density_official, pop_density)) %&gt;% # drop a small number of apparent data errors filter(light_avg &gt; 1e-5) county_light_sf &lt;- tar_read(county_sf) d_df &lt;- data_df %&gt;% dplyr::select(state:pop_density_official) %&gt;% mutate(area_diff_pct = calc_area / atotal - 1, pop_densisty_diff_pct = pop_density / pop_density_official - 1) 2.2.1 Predictors and data transformations I have a plausible causal conjecture for two easily accessible variables associated with “human presence” which might predict radiance: pop_density: the more people that live in a unit area, the more built out the area will be; the more built out an area is, the more light generated in that area medincome: the wealthier people are, the more light they will generate pop_density and medincome likely are correlated, so I may use only one of them. In the plots below, the blue line is a LOESS curve (locally estimated scatterplot smoothing), the red line a straight regression line. Figures 2.2 to 2.5 show that light_avg and pop_density work best on a log scale. # population density as predictor d_df %&gt;% ggplot() + geom_point(aes(pop_density, light_avg, color = state), alpha = 0.5) + geom_smooth(aes(pop_density, light_avg), se = FALSE, size = 0.5) + geom_smooth(aes(pop_density, light_avg), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = scales::label_number_si()) + labs(title = &quot;light_avg by pop_density&quot;) Figure 2.2: light_avg by pop_density (all states) d_df %&gt;% ggplot(aes(pop_density, light_avg)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = scales::label_number_si()) + facet_wrap(~state)+ labs(title = &quot;light_avg by pop_density&quot;) Figure 2.3: light_avg by pop_density (faceted by state) d_df %&gt;% ggplot() + geom_point(aes(pop_density, light_avg, color = state), alpha = 0.5) + geom_smooth(aes(pop_density, light_avg), se = FALSE, size = 0.5) + geom_smooth(aes(pop_density, light_avg), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10(labels = scales::label_number_si()) + scale_y_log10() + labs(title = &quot;log_light_avg by log_pop_density&quot;, x = &quot;pop_density (log10 scale)&quot;, y = &quot;light_avg (log10 scale)&quot;) Figure 2.4: log_light_avg by log_pop_density (all states) d_df %&gt;% ggplot(aes(pop_density, light_avg)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10(labels = scales::label_number_si()) + scale_y_log10() + facet_wrap(~state)+ labs(title = &quot;log_light_avg by log_pop_density&quot;, x = &quot;pop_density (log10 scale)&quot;, y = &quot;light_avg (log10 scale)&quot;) Figure 2.5: log_light_avg by log_pop_density (faceted by state) Figures 2.6 to 2.8 show that medincome also works best on a log scale. # median income as predictor d_df %&gt;% ggplot() + geom_point(aes(medincome, light_avg, color = state), alpha = 0.5) + geom_smooth(aes(medincome, light_avg), se = FALSE, size = 0.5) + geom_smooth(aes(medincome, light_avg), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = scales::label_number_si()) + # scale_y_log10() + #facet_wrap(~state)+ labs(title = &quot;light_avg by medincome&quot;, subtitle = glue(&quot;correlation: {round(cor(d_df$pop_density, d_df$medincome), 2)}&quot;)) Figure 2.6: light_avg by medincome (all states) d_df %&gt;% ggplot() + geom_point(aes(medincome, light_avg, color = state), alpha = 0.5) + geom_smooth(aes(medincome, light_avg), se = FALSE, size = 0.5) + geom_smooth(aes(medincome, light_avg), method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10(labels = scales::label_number_si()) + scale_y_log10() + labs(title = &quot;log_light_avg by log_medincome&quot;, x = &quot;medincome (log10 scale)&quot;, y = &quot;light_avg (log10 scale)&quot;) Figure 2.7: log_light_avg by log_medincome (all states) d_df %&gt;% ggplot(aes(medincome, light_avg)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = scales::label_number_si()) + # scale_y_log10() + facet_wrap(~state)+ labs(title = &quot;light_avg by medincome&quot;) Figure 2.8: light_avg by medincome (faceted by state) d_df %&gt;% ggplot(aes(medincome, light_avg)) + geom_point(alpha = 0.5) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_log10(labels = scales::label_number_si()) + scale_y_log10() + facet_wrap(~state)+ labs(title = &quot;log_light_avg by log_medincome&quot;, x = &quot;medincome (log10 scale)&quot;, y = &quot;light_avg (log10 scale)&quot;) Figure 2.9: log_light_avg by log_medincome (faceted by state) pop_density and medincome are correlated (corr = 0.35) but less so for states with big urban areas (especially VA). Since they are correlated, and my goal is to check whether we can associate radiance levels with a demographic change, it’s best if I don’t include both in models. Since light_avg ~ pop_density (corr = 0.94) has less variance than light_avg ~ medincome (corr = 0.37). 2.2.2 Radiance values’ distribution by state Each pixel has a light radiance value. Below are radiance values by state in a density plot (Figure 2.10) and an empirical cumulative distribution (Figure 2.11) . The distributions are similar in shape. The most noticeable difference is that the portion of zero values (completely black pixels) differs by state. county_light_sf %&gt;% mutate(value = value + 1e-6, state = fct_reorder(state, value, median)) %&gt;% ggplot(aes(value, color = state)) + geom_density(size = 0.5) + scale_x_log10() + labs(title = &quot;Radiance density&quot;, x = &quot;light value (log10 scale)&quot;, y = &quot;&quot;) Figure 2.10: Radiance density 2000 county_light_sf %&gt;% mutate(state = fct_reorder(state, value, median)) %&gt;% ggplot(aes(value, color = state)) + stat_ecdf(geom = &quot;line&quot;, pad = FALSE, size = 0.5, alpha = 0.6) + scale_x_log10() + scale_y_continuous(label = percent_format()) + labs(title = &quot;Radiance ECD&quot;, x = &quot;light value (log10 scale)&quot;, y = &quot;&quot;) Figure 2.11: Radiance empirical cumulative density 2000 2.2.3 \\(R^2\\) and linear relationships: slope estimates by state models_nested &lt;- d_df %&gt;% mutate(log_light_avg = log10(light_avg), log_pop_density = log10(pop_density)) %&gt;% select(state, log_light_avg, log_pop_density) %&gt;% group_by(state) %&gt;% nest() %&gt;% mutate(model = map(data, function(df) lm(log_light_avg ~ log_pop_density, data = df)), tidied = map(model, tidy), augmented = map(model, broom::augment), glanced = map(model, broom::glance) ) models &lt;- left_join(tidied &lt;- models_nested %&gt;% unnest(c(state, tidied)), adj_r_sqr &lt;- models_nested %&gt;% unnest(c(state, glanced)) %&gt;% select(state, adj.r.squared, sigma), by = &quot;state&quot; ) %&gt;% filter(!term == &quot;(Intercept)&quot;) %&gt;% select(state, term, estimate, estimate_std.error = std.error, adj.r.squared, adj.r.squared_sigma = sigma) %&gt;% arrange(desc(adj.r.squared)) state_levels &lt;- rev(models$state) models %&gt;% pivot_longer(cols = c(estimate, adj.r.squared), names_to = &quot;metric&quot;, values_to = &quot;value&quot;) %&gt;% mutate(state = factor(state, levels = state_levels)) %&gt;% ggplot(aes(value, state)) + geom_point() + expand_limits(x = 0) + facet_wrap(~ metric, scales = &quot;free_x&quot;, nrow = 1) + labs(title = &quot;R^2 and estimated slope of\\nlm(log_light_avg ~ log_pop_density)&quot;) Figure 2.12: R^2 and estimated slope of lm(log_light_avg ~ log_pop_density) 2.2.4 EDA summary comments The relationship between \\(log_{10}(light\\_avg)\\) and \\(log_{10}(pop\\_density)\\) in figures 2.4 and 2.5)isn’t quite linear. The plots suggest a concave curve (a second order polynomial), and there are differences by state. So I expect simple linear models to perform worse than more sophisticated ones. Nonetheless, I want to see how good linear models are, since they are simple and inexpensive. "],["modeling-and-model-comparison.html", "3 Modeling and model comparison 3.1 Train and test on training data set 3.2 Assessing model performance with the holdout data set 3.3 Comparing 2000 and 2010", " 3 Modeling and model comparison As noted in the EDA section: The relationship between \\(log_{10}(light\\_avg)\\) and \\(log_{10}(pop\\_density)\\) in figures 2.4 and 2.5) isn’t quite linear. The plots suggest a concave curve (a second order polynomial), and there are differences by state. So I expect simple linear models to perform worse than more sophisticated ones. Nonetheless, I want to see how good linear models are, since they are simple and inexpensive. In this section I do the following: Prepare train-test and holdout data sets Build (and where necessary, train) some models, then compare them using performance metrics Test the best performing models against the holdout data set. I use the following performance metrics: Concordance correlation coefficient (ccc) according the help for yardstick::ccc() “is a metric of both consistency/correlation and accuracy,” R-Squared according the help for yardstick::rsq() “is simply the squared correlation between truth and estimate” and is guaranteed to be between \\((0,1)\\) in contrast to yardstick::rsq_trad() which uses the sum of squares. I use metrics that are scale-free, since I want the freedom to use models with different transformations of the data. The principle metric is ccc. data_df &lt;- tar_read(all_df) %&gt;% #fix NAs mutate(atotal = if_else(!is.na(atotal), atotal, calc_area), pop_density_official = if_else(!is.na(pop_density_official), pop_density_official, pop_density)) %&gt;% # drop apparent data errors/artifacts filter(light_avg &gt; 1e-5) # prepare data for train-test and holdout d_df_all &lt;- data_df %&gt;% dplyr::select(state:pop_density_official) %&gt;% mutate(area_diff_pct = 1 - calc_area / atotal, pop_densisty_diff_pct = 1 - pop_density / pop_density_official) %&gt;% # avoid zero values mutate(log_light_avg = log10(light_avg + 1e-6), log_pop_density = log10(pop_density + 1e-6), log_pop_density_official = log10(pop_density_official + 1e-6)) d_df &lt;- d_df_all %&gt;% select(state, county, light_avg, log_light_avg, pop_density, log_pop_density, pop_density_official, log_pop_density_official) # following https://cran.r-project.org/web/packages/rsample/vignettes/Working_with_rsets.html set.seed(123) main_split = initial_split(d_df, strata = c(&quot;state&quot;)) train_split &lt;- analysis(main_split) holdout &lt;- assessment(main_split) light_folds &lt;- vfold_cv(train_split, v = n_folds, repeats = 1) # inspiration/source: Dave Robinson&#39;s coding videos prep_juice &lt;- function(x) juice(prep(x)) mset &lt;- metric_set(rsq, ccc) # use scale-free metrics (not rmse) grid_control &lt;- control_grid(save_pred = TRUE, save_workflow = TRUE, extract = extract_model) augment.workflow &lt;- function(x, newdata, ...) { predict(x, newdata, ...) %&gt;% bind_cols(newdata) } predict_on_holdout &lt;- function(workflow, tbl_train, tbl_test) { workflow %&gt;% fit(tbl_train) %&gt;% augment(tbl_test) } # for use in fit_resamples() keep_pred &lt;- control_resamples(save_pred = TRUE, save_workflow = TRUE) 3.1 Train and test on training data set 3.1.1 lin1: light_avg ~ pop_density Let’s start simple. In lin1 the data is concentrated in the smaller radiance values, and the model is underestimating most high values. lm_model &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% set_mode(&quot;regression&quot;) my_formula &lt;- &quot;light_avg ~ pop_density + state + county&quot; lin_rec &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula)) %&gt;% update_role(c(&quot;state&quot;, &quot;county&quot;), new_role = &quot;id variable&quot;) lin1_wf &lt;- workflow() %&gt;% add_recipe(lin_rec) %&gt;% add_model(lm_model) lin1_res &lt;- lin1_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lin1_assess_res &lt;- collect_metrics(lin1_res) %&gt;% mutate(model = &quot;lin1: light_avg ~ pop_density&quot;) lin1_metric_summary &lt;- lin1_assess_res %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lin1_metric_summary[[1, 1]]} = {round(lin1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lin1_metric_summary[[2, 1]]} = {round(lin1_metric_summary[[2, 2]], 3)}&quot;) lin1_pred &lt;- collect_predictions(lin1_res) lin1_pred %&gt;% ggplot(aes(x = light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + labs(title = glue(&quot;{lin1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.1: lin1: Simplest linear model 3.1.2 lin2: light_avg ~ pop_density_official Should I use official area values from the US Census Bureau to calculate population density instead of area values calculated based on the county boundaries? In a word: no. Using official area values, rsq and ccc are slightly lower than Figure 3.1, perhaps because pop_density is calculated using the same boundaries I’m using to determine which light pixels are part of each county, and therefore I’m dealing with similar error in both. I use the area values I calculated in all other models. my_formula &lt;- &quot;light_avg ~ pop_density_official&quot; lin_rec2 &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula)) lin2_wf &lt;- workflow() %&gt;% add_recipe(lin_rec2) %&gt;% add_model(lm_model) # defined above lin2_res &lt;- lin2_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lin2_assess_res &lt;- collect_metrics(lin2_res) %&gt;% mutate(model = glue(&quot;lin2: {my_formula}&quot;)) lin2_metric_summary &lt;- lin2_assess_res %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lin2_metric_summary[[1, 1]]} = {round(lin2_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lin2_metric_summary[[2, 1]]} = {round(lin2_metric_summary[[2, 2]], 3)}&quot;) lin2_pred &lt;- collect_predictions(lin2_res) lin2_pred %&gt;% ggplot(aes(x = light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + labs(title = glue(&quot;{lin2_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.2: lin2: Using official area values to calculate population density? 3.1.3 lin3: log_light_avg ~ log_pop_density With both predictor and response on a log scale, performance metrics are better. Compare with lin1 in Figure 3.1. my_formula &lt;- &quot;log_light_avg ~ log_pop_density&quot; lin_rec3 &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula)) lin3_wf &lt;- workflow() %&gt;% add_recipe(lin_rec3) %&gt;% add_model(lm_model) # defined above lin3_res &lt;- lin3_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lin3_assess_res &lt;- collect_metrics(lin3_res) %&gt;% mutate(model = glue(&quot;lin3: {my_formula}&quot;)) lin3_metric_summary &lt;- lin3_assess_res %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lin3_metric_summary[[1, 1]]} = {round(lin3_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lin3_metric_summary[[2, 1]]} = {round(lin3_metric_summary[[2, 2]], 3)}&quot;) lin3_pred &lt;- collect_predictions(lin3_res) lin3_pred %&gt;% ggplot(aes(x = log_light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + # coord_obs_pred() + labs(title = glue(&quot;{lin3_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.3: lin3: Simplest linear model with log10 transformations 3.1.4 pol1: log_light_avg ~ poly(log_pop_density, 2) Since the data in Figure 2.4 looks like it has close to a quadratic relationship (a concave curve), let’s try a second order polynomial. Performance is quite good. my_formula_basic &lt;- &quot;log_light_avg ~ log_pop_density&quot; my_formula &lt;- &quot;log_light_avg ~ poly(log_pop_density, 2)&quot; pol1_rec &lt;- recipe( data = analysis(light_folds$splits[[1]]), formula = as.formula(my_formula_basic)) %&gt;% step_poly(log_pop_density, degree = 2) pol1_wf &lt;- workflow() %&gt;% add_recipe(pol1_rec) %&gt;% add_model(lm_model) # defined above pol1_res &lt;- pol1_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) pol1_assess_res &lt;- collect_metrics(pol1_res) %&gt;% mutate(model = glue(&quot;pol1: {my_formula}&quot;)) pol1_metric_summary &lt;- pol1_assess_res %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{pol1_metric_summary[[1, 1]]} = {round(pol1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {pol1_metric_summary[[2, 1]]} = {round(pol1_metric_summary[[2, 2]], 3)}&quot;) pol1_pred &lt;- collect_predictions(pol1_res) pol1_pred %&gt;% ggplot(aes(x = log_light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + # coord_obs_pred() + labs(title = glue(&quot;{pol1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.4: pol1: Linear model with second order polynomial 3.1.5 lme1: multi-level model with lme4::lmer Since states differ in the range and distribution of radiance values, are there improvements if I use a fixed effects model “log_light_avg ~ log_pop_density + (log_pop_density | state)?” Unfortunately not. There is no meaningful improvement over Figure 3.3. Apparently state doesn’t seem to hold enough unique information to be helpful. lme_model &lt;- linear_reg() %&gt;% set_engine(&quot;lmer&quot;) %&gt;% set_mode(&quot;regression&quot;) my_formula &lt;- &quot;log_light_avg ~ log_pop_density + (log_pop_density | state)&quot; lme1_wf &lt;- workflow() %&gt;% add_variables(outcomes = log_light_avg, predictors = c(log_pop_density, state) ) %&gt;% add_model( lme_model, formula = as.formula(my_formula) ) lme1_res &lt;- lme1_wf %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) lme1_assess_res &lt;- collect_metrics(lme1_res) %&gt;% mutate(model = glue(&quot;lme1: {my_formula}&quot;)) lme1_metric_summary &lt;- lme1_assess_res %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{lme1_metric_summary[[1, 1]]} = {round(lme1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {lme1_metric_summary[[2, 1]]} = {round(lme1_metric_summary[[2, 2]], 3)}&quot;) lme1_pred &lt;- collect_predictions(lme1_res) lme1_pred %&gt;% ggplot(aes(x = log_light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + theme(plot.title = element_text(size = 14)) + labs(title = glue(&quot;{lme1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.5: lme1: Multi-level model using ‘state’ 3.1.6 bs1: linear model with b-spline Since Figure 3.3 seems to be underestimating high and low radiance, let’s try a spline. First I tune the model to determine how many knots to include in the spline: bs_rec &lt;- recipe(log_light_avg ~ log_pop_density, data = analysis(light_folds$splits[[1]])) %&gt;% step_ns(log_pop_density, deg_free = tune(&quot;log_pop_density&quot;)) bs_model &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% set_mode(&quot;regression&quot;) my_formula = &quot;log_light_avg ~ bs(log_pop_density)&quot; bs1_wf &lt;- workflow() %&gt;% add_recipe(bs_rec) %&gt;% add_model(bs_model) k_grid &lt;- tibble(log_pop_density = 3:6) bs_tune &lt;- bs1_wf %&gt;% tune_grid(resamples = light_folds, grid = k_grid, metrics = mset, control = grid_control) autoplot(bs_tune) + labs(title = &quot;Tuning bs1&quot;) Figure 3.6: Tuning bs1 I’ll use 5 knots, which maximizes both ccc and rsq (though the differences are marginal) bs_wf_best &lt;- bs1_wf %&gt;% finalize_workflow(select_best(bs_tune, metric = &quot;ccc&quot;)) select_best(bs_tune, metric = &quot;ccc&quot;) %&gt;% gt() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #yvdakhldif .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #yvdakhldif .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yvdakhldif .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #yvdakhldif .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #yvdakhldif .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yvdakhldif .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yvdakhldif .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #yvdakhldif .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #yvdakhldif .gt_column_spanner_outer:first-child { padding-left: 0; } #yvdakhldif .gt_column_spanner_outer:last-child { padding-right: 0; } #yvdakhldif .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #yvdakhldif .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #yvdakhldif .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #yvdakhldif .gt_from_md > :first-child { margin-top: 0; } #yvdakhldif .gt_from_md > :last-child { margin-bottom: 0; } #yvdakhldif .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #yvdakhldif .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #yvdakhldif .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yvdakhldif .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #yvdakhldif .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yvdakhldif .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #yvdakhldif .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #yvdakhldif .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yvdakhldif .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yvdakhldif .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #yvdakhldif .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yvdakhldif .gt_sourcenote { font-size: 90%; padding: 4px; } #yvdakhldif .gt_left { text-align: left; } #yvdakhldif .gt_center { text-align: center; } #yvdakhldif .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #yvdakhldif .gt_font_normal { font-weight: normal; } #yvdakhldif .gt_font_bold { font-weight: bold; } #yvdakhldif .gt_font_italic { font-style: italic; } #yvdakhldif .gt_super { font-size: 65%; } #yvdakhldif .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } log_pop_density .config 5 Preprocessor3_Model1 Both ccc and rsq are better, and the high and low predictions are not consistently underestimated: bs1_res &lt;- bs_wf_best %&gt;% fit_resamples(resamples = light_folds, metrics = mset, control = keep_pred) bs1_assess_res &lt;- collect_metrics(bs1_res) %&gt;% mutate(model = glue(&quot;bs1: {my_formula}&quot;)) bs1_metric_summary &lt;- bs1_assess_res %&gt;% dplyr::select(&quot;.metric&quot;, .estimate = &quot;mean&quot;, &quot;n&quot;, &quot;std_err&quot;, &quot;model&quot;) metric_summary_for_plot &lt;- glue(&quot;{bs1_metric_summary[[1, 1]]} = {round(bs1_metric_summary[[1, 2]], 3)}&quot;, &quot;; {bs1_metric_summary[[2, 1]]} = {round(bs1_metric_summary[[2, 2]], 3)}&quot;) bs1_pred &lt;- collect_predictions(bs1_res) bs1_pred %&gt;% ggplot(aes(x = log_light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + theme(plot.title = element_text(size = 14)) + labs(title = glue(&quot;{bs1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.7: bs1: linear model with B-spline (five knots) to capture curvature 3.1.7 XGBoost: log_light_avg ~ log_pop_density + state Now a non-linear model and one that needs training: boosted trees using XGBoost. In this model state categories are dummy variables. set.seed(2021) xg_rec &lt;- recipe(log_light_avg ~ log_pop_density + state, data = analysis(light_folds$splits[[1]])) %&gt;% step_dummy(state) xg_wf &lt;- workflow() %&gt;% add_recipe(xg_rec) %&gt;% add_model(boost_tree(mode = &quot;regression&quot;, mtry = tune(), trees = tune(), # tree_depth = , # default is 6 learn_rate = .01) %&gt;% set_engine(&quot;xgboost&quot;)) xg_tune &lt;- xg_wf %&gt;% tune_grid(light_folds, grid = crossing(mtry = c(2, 5, 8, 11), trees = seq(50, 400, 50), #threshold = c(0.01) # default is 0.01 ), metrics = mset, control = grid_control) Tuning the model …. results suggest using between 200 and 400 trees with equal performance including 8 or 11 variables at each split: autoplot(xg_tune) + labs(title = &quot;Tuning xg1&quot;) Figure 3.8: Tuning xg1 The best fit includes 400 trees and using \\(mtry = 8\\) to randomly sample 8 variables at each split (which is nearly all of them in this case). The benefit of 400 trees versus 300 is very small, and given we have ~650 data points for training (before considering cv folds), I use the lesser number. Fewer trees reduces the chance of overfitting. xg_wf_best &lt;- xg_wf %&gt;% finalize_workflow(select_best(xg_tune, metric = &quot;ccc&quot;)) %&gt;% update_model(boost_tree(mode = &quot;regression&quot;, mtry = 8, trees = 300, # tree_depth = 3, learn_rate = .01) %&gt;% set_engine(&quot;xgboost&quot;)) So I use these: print(xg_wf_best) ## ══ Workflow ═════════════════════════════════════════════════════════════════════ ## Preprocessor: Recipe ## Model: boost_tree() ## ## ── Preprocessor ───────────────────────────────────────────────────────────────── ## 1 Recipe Step ## ## • step_dummy() ## ## ── Model ──────────────────────────────────────────────────────────────────────── ## Boosted Tree Model Specification (regression) ## ## Main Arguments: ## mtry = 8 ## trees = 300 ## learn_rate = 0.01 ## ## Computational engine: xgboost Summary metrics are good, however the model is underestimating high radiance values: my_formula &lt;- &quot;log_light_avg ~ log_pop_density + state&quot; xg_fit_best &lt;- xg_wf_best %&gt;% fit(train_split) # TODO: confirm I should be using full train-test set now that it&#39;s tuned xg1_res &lt;- xg_fit_best %&gt;% last_fit(main_split, metrics = mset) xg1_assess_res &lt;- collect_metrics(xg1_res) %&gt;% mutate(model = glue(&quot;xg1: {my_formula}&quot;)) xg1_metric_summary &lt;- xg1_assess_res %&gt;% mutate(n = n_folds, std_err = NA_real_) %&gt;% dplyr::select(.metric, .estimate, n, std_err, model) metric_summary_for_plot &lt;- glue(&quot;{xg1_metric_summary[[2, 1]]} = {round(xg1_metric_summary[[2, 2]], 3)}&quot;, &quot;; {xg1_metric_summary[[1, 1]]} = {round(xg1_metric_summary[[1, 2]], 3)}&quot;) xg1_pred &lt;- collect_predictions(xg1_res) xg1_pred %&gt;% ggplot(aes(x = log_light_avg, y = .pred)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + theme(plot.title = element_text(size = 14)) + labs(title = glue(&quot;{xg1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: {metric_summary_for_plot}&quot;) ) Figure 3.9: xg1: Random forest with boosted graidient descent 3.1.8 Summary of train-test results all_metrics &lt;- bind_rows( lin1_metric_summary, lin2_metric_summary, lin3_metric_summary, pol1_metric_summary, xg1_metric_summary, lme1_metric_summary, bs1_metric_summary, NULL ) %&gt;% filter(.metric %in% c(&quot;ccc&quot;, &quot;rsq&quot;)) model_levels = all_metrics %&gt;% filter(.metric == &quot;ccc&quot;) %&gt;% arrange(.estimate) %&gt;% pull(model) all_metrics %&gt;% mutate(model = factor(model, levels = model_levels)) %&gt;% ggplot(aes(.estimate, model)) + geom_errorbarh(aes(xmax = .estimate + std_err, xmin = .estimate - std_err), height = 0.2) + geom_point() + expand_limits(x = 1.0) + facet_wrap( ~ .metric, nrow = 1) + theme(plot.title.position = &quot;plot&quot;) + labs(title = glue(&quot;Comparing model performance for metrics &quot;, &quot;{glue_collapse(sort(unique(all_metrics$.metric)), sep = &#39;, &#39;)}&quot;), subtitle = &quot;Performance on train-test set&quot;, x = &quot;mean metric estimate across all folds; error bars +/- std_err&quot;) Figure 3.10: Summary of train-test results all_metrics %&gt;% arrange(.metric, desc(.estimate)) %&gt;% gt() %&gt;% tab_header( title = md(&quot;**Model evaluation on train-test data set**&quot;) ) %&gt;% fmt_number(columns = c(.estimate, std_err), decimals = 3) %&gt;% fmt_missing(columns = everything(), missing_text = &quot;---&quot;) %&gt;% cols_align(columns = model, align = &quot;left&quot;) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #wtekawcftw .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #wtekawcftw .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wtekawcftw .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #wtekawcftw .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #wtekawcftw .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wtekawcftw .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wtekawcftw .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #wtekawcftw .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #wtekawcftw .gt_column_spanner_outer:first-child { padding-left: 0; } #wtekawcftw .gt_column_spanner_outer:last-child { padding-right: 0; } #wtekawcftw .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #wtekawcftw .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #wtekawcftw .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #wtekawcftw .gt_from_md > :first-child { margin-top: 0; } #wtekawcftw .gt_from_md > :last-child { margin-bottom: 0; } #wtekawcftw .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #wtekawcftw .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #wtekawcftw .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wtekawcftw .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #wtekawcftw .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wtekawcftw .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #wtekawcftw .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #wtekawcftw .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wtekawcftw .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wtekawcftw .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #wtekawcftw .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wtekawcftw .gt_sourcenote { font-size: 90%; padding: 4px; } #wtekawcftw .gt_left { text-align: left; } #wtekawcftw .gt_center { text-align: center; } #wtekawcftw .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #wtekawcftw .gt_font_normal { font-weight: normal; } #wtekawcftw .gt_font_bold { font-weight: bold; } #wtekawcftw .gt_font_italic { font-style: italic; } #wtekawcftw .gt_super { font-size: 65%; } #wtekawcftw .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Model evaluation on train-test data set .metric .estimate n std_err model ccc 0.962 10 &mdash; xg1: log_light_avg ~ log_pop_density + state ccc 0.959 10 0.004 bs1: log_light_avg ~ bs(log_pop_density) ccc 0.957 10 0.004 pol1: log_light_avg ~ poly(log_pop_density, 2) ccc 0.947 10 0.004 lin3: log_light_avg ~ log_pop_density ccc 0.945 10 0.004 lme1: log_light_avg ~ log_pop_density + (log_pop_density | state) ccc 0.907 10 0.013 lin1: light_avg ~ pop_density ccc 0.881 10 0.030 lin2: light_avg ~ pop_density_official rsq 0.956 10 &mdash; xg1: log_light_avg ~ log_pop_density + state rsq 0.953 10 0.007 bs1: log_light_avg ~ bs(log_pop_density) rsq 0.951 10 0.008 pol1: log_light_avg ~ poly(log_pop_density, 2) rsq 0.931 10 0.008 lin3: log_light_avg ~ log_pop_density rsq 0.931 10 0.008 lme1: log_light_avg ~ log_pop_density + (log_pop_density | state) rsq 0.931 10 0.020 lin1: light_avg ~ pop_density rsq 0.922 10 0.022 lin2: light_avg ~ pop_density_official 3.1.9 Summary: train-test As expected, the highest-performing models are not the simplest. I keep the four best-performing models for the next stage. 3.2 Assessing model performance with the holdout data set In this section I use data the models haven’t seen yet (the holdout data set). lin3 summary metrics are quite good, however again the curvature in the data is visible in the way the model is underestimating high and low radiance values: lin3_pred &lt;- lin3_wf %&gt;% predict_on_holdout(., train_split, holdout) #predict_on_holdout(., train, holdout_df) lin3_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_light_avg, estimate = .pred), ccc(lin3_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(lin3_metric_summary$model)) lin3_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{lin3_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{lin3_metric_summary[[2, 1]]} = {round(lin3_metric_summary[[2, 3]], 3)}&quot;, &quot;; {lin3_metric_summary[[1, 1]]} = {round(lin3_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.11: lin3 using holdout set pol1 looks good but is underestimating high radiance values: pol1_pred &lt;- pol1_wf %&gt;% predict_on_holdout(., train_split, holdout) #predict_on_holdout(., train, holdout_df) pol1_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_light_avg, estimate = .pred), ccc(lin3_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(pol1_metric_summary$model)) pol1_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{pol1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{pol1_metric_summary[[2, 1]]} = {round(pol1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {pol1_metric_summary[[1, 1]]} = {round(pol1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.12: pol1 using holdout set Again lme1 fails to do better than lin3: # error=TRUE to continue execution in case model fails to converge lme1_pred &lt;- lme1_wf %&gt;% predict_on_holdout(., train_split, holdout) lme1_metric_summary &lt;- bind_rows( rsq(lme1_pred, truth = log_light_avg, estimate = .pred), ccc(lme1_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(lme1_metric_summary$model)) lme1_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{lme1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{lme1_metric_summary[[2, 1]]} = {round(lme1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {lme1_metric_summary[[1, 1]]} = {round(lme1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.13: lme1 using holdout set Again bs1 is performing quite well: bs1_pred &lt;- bs_wf_best %&gt;% predict_on_holdout(., train_split, holdout) bs1_metric_summary &lt;- bind_rows( rsq(bs1_pred, truth = log_light_avg, estimate = .pred), ccc(bs1_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(bs1_metric_summary$model)) bs1_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{bs1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{bs1_metric_summary[[2, 1]]} = {round(bs1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {bs1_metric_summary[[1, 1]]} = {round(bs1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.14: bs1 using holdout set xg1 performance metrics are good, but the model is again underestimating at the high end: xg_pred &lt;- xg_fit_best %&gt;% predict_on_holdout(., train_split, holdout) xg1_metric_summary &lt;- bind_rows( rsq(xg_pred, truth = log_light_avg, estimate = .pred), ccc(xg_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(xg1_metric_summary$model)) xg_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{xg1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{xg1_metric_summary[[2, 1]]} = {round(xg1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {xg1_metric_summary[[1, 1]]} = {round(xg1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.15: xg1 using holdout set 3.2.1 Summary: model evaluation using holdout data set Results are similar for all models. The more sophisticated models perform slightly better, with the exception of the multi-level model lme1, which is not beating the very simple lin3. I exclude lme1 from the next stage. all_metrics &lt;- bind_rows( lin3_metric_summary, pol1_metric_summary, xg1_metric_summary, lme1_metric_summary, bs1_metric_summary ) model_levels = all_metrics %&gt;% filter(.metric == &quot;ccc&quot;) %&gt;% arrange(.estimate) %&gt;% pull(model) all_metrics %&gt;% mutate(model = factor(model, levels = model_levels)) %&gt;% ggplot(aes(.estimate, model)) + geom_point() + geom_label(aes(label = str_pad(round(.estimate, 3), width = 5, side = &quot;right&quot;, pad = &quot;0&quot;) ), size = 3, nudge_x = -0.1, hjust = 1) + expand_limits(x = 0) + facet_wrap(~ .metric, scales = &quot;free_x&quot;) + theme(legend.position = &quot;none&quot;, plot.title.position = &quot;plot&quot;) + labs(title = &quot;Model evaluation on holdout data set&quot;, x = &quot;metric estimate&quot;, y = &quot;&quot;) Figure 3.16: Summary of holdout results all_metrics %&gt;% dplyr::select(-.estimator) %&gt;% arrange(.metric, desc(.estimate)) %&gt;% gt() %&gt;% tab_header( title = md(&quot;**Model evaluation on holdout data set**&quot;) ) %&gt;% fmt_number(columns = .estimate, decimals = 3) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #arqpwajcvt .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #arqpwajcvt .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #arqpwajcvt .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #arqpwajcvt .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #arqpwajcvt .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #arqpwajcvt .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #arqpwajcvt .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #arqpwajcvt .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #arqpwajcvt .gt_column_spanner_outer:first-child { padding-left: 0; } #arqpwajcvt .gt_column_spanner_outer:last-child { padding-right: 0; } #arqpwajcvt .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #arqpwajcvt .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #arqpwajcvt .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #arqpwajcvt .gt_from_md > :first-child { margin-top: 0; } #arqpwajcvt .gt_from_md > :last-child { margin-bottom: 0; } #arqpwajcvt .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #arqpwajcvt .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #arqpwajcvt .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #arqpwajcvt .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #arqpwajcvt .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #arqpwajcvt .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #arqpwajcvt .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #arqpwajcvt .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #arqpwajcvt .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #arqpwajcvt .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #arqpwajcvt .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #arqpwajcvt .gt_sourcenote { font-size: 90%; padding: 4px; } #arqpwajcvt .gt_left { text-align: left; } #arqpwajcvt .gt_center { text-align: center; } #arqpwajcvt .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #arqpwajcvt .gt_font_normal { font-weight: normal; } #arqpwajcvt .gt_font_bold { font-weight: bold; } #arqpwajcvt .gt_font_italic { font-style: italic; } #arqpwajcvt .gt_super { font-size: 65%; } #arqpwajcvt .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Model evaluation on holdout data set .metric .estimate model ccc 0.975 bs1: log_light_avg ~ bs(log_pop_density) ccc 0.963 xg1: log_light_avg ~ log_pop_density + state ccc 0.962 lin3: log_light_avg ~ log_pop_density ccc 0.962 pol1: log_light_avg ~ poly(log_pop_density, 2) ccc 0.958 lme1: log_light_avg ~ log_pop_density + (log_pop_density | state) rsq 0.961 bs1: log_light_avg ~ bs(log_pop_density) rsq 0.957 xg1: log_light_avg ~ log_pop_density + state rsq 0.937 lin3: log_light_avg ~ log_pop_density rsq 0.937 pol1: log_light_avg ~ poly(log_pop_density, 2) rsq 0.937 lme1: log_light_avg ~ log_pop_density + (log_pop_density | state) 3.3 Comparing 2000 and 2010 I use the four top-performing models to predict changes in average radiance in 2010 given population density in 2010. TODO: Review/update the commentary data_df_c &lt;- tar_read(all_df_c) %&gt;% #fix NAs mutate(atotal = if_else(!is.na(atotal), atotal, calc_area), pop_density_official = if_else(!is.na(pop_density_official), pop_density_official, pop_density)) %&gt;% # drop apparent data errors/artifacts filter(light_avg &gt; 1e-5) # prepare data for train-test and holdout d_df_c &lt;- data_df_c %&gt;% dplyr::select(state:pop_density_official) %&gt;% mutate(area_diff_pct = 1 - calc_area / atotal, pop_densisty_diff_pct = 1 - pop_density / pop_density_official) assess_df &lt;- d_df_c %&gt;% # avoid zero values mutate(log_light_avg = log10(light_avg + 1e-6), log_pop_density = log10(pop_density + 1e-6), log_pop_density_official = log10(pop_density_official + 1e-6)) set.seed(2021) lin3 looks pretty good but underestimates high 2010 radiance values. lin3_pred &lt;- lin3_wf %&gt;% predict_on_holdout(., holdout, assess_df) lin3_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_light_avg, estimate = .pred), ccc(lin3_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(lin3_metric_summary$model)) lin3_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{lin3_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{lin3_metric_summary[[2, 1]]} = {round(lin3_metric_summary[[2, 3]], 3)}&quot;, &quot;; {lin3_metric_summary[[1, 1]]} = {round(lin3_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.17: lin1 assess set results pol1 is overestimating low 2010 radiance values and underestimating most other values: pol1_pred &lt;- pol1_wf %&gt;% predict_on_holdout(., holdout, assess_df) pol1_metric_summary &lt;- bind_rows( rsq(lin3_pred, truth = log_light_avg, estimate = .pred), ccc(lin3_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(pol1_metric_summary$model)) pol1_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{pol1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{pol1_metric_summary[[2, 1]]} = {round(pol1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {pol1_metric_summary[[1, 1]]} = {round(pol1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.18: pol1 assess set results Like pol1, bs1 is overestimating low 2010 radiance values and underestimating most other values: bs1_pred &lt;- bs_wf_best %&gt;% predict_on_holdout(., holdout, assess_df) bs1_metric_summary &lt;- bind_rows( rsq(bs1_pred, truth = log_light_avg, estimate = .pred), ccc(bs1_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(bs1_metric_summary$model)) bs1_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{bs1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{bs1_metric_summary[[2, 1]]} = {round(bs1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {bs1_metric_summary[[1, 1]]} = {round(bs1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.19: bs1 assess set results xg1 is under-predicting most values: xg_pred &lt;- xg_fit_best %&gt;% predict_on_holdout(., holdout, assess_df) xg1_metric_summary &lt;- bind_rows( rsq(xg_pred, truth = log_light_avg, estimate = .pred), ccc(xg_pred, truth = log_light_avg, estimate = .pred) ) %&gt;% mutate(model = unique(xg1_metric_summary$model)) xg_pred %&gt;% ggplot(aes(log_light_avg, .pred, color = state)) + geom_abline(lty = 2, alpha = 0.5) + geom_point(alpha = 0.15) + coord_fixed() + labs(title = glue(&quot;{xg1_metric_summary$model}&quot;), subtitle = glue(&quot;Actual and predicted light_avg: &quot;, &quot;{xg1_metric_summary[[2, 1]]} = {round(xg1_metric_summary[[2, 3]], 3)}&quot;, &quot;; {xg1_metric_summary[[1, 1]]} = {round(xg1_metric_summary[[1, 3]], 3)}&quot;) ) Figure 3.20: xg1 assess set results 3.3.1 Summary: model performance on census 2010 data. The simpler models do better: lin3, pol1, and bs1 are essentially equal in performance while xg1 does worse and underestimates most radiance values. all_means &lt;- bind_rows( with(lin3_pred, t.test(.pred, log_light_avg, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(lin3_metric_summary$model)), with(xg1_pred, t.test(.pred, log_light_avg, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(xg1_metric_summary$model)), with(pol1_pred, t.test(.pred, log_light_avg, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(pol1_metric_summary$model)), with(bs1_pred, t.test(.pred, log_light_avg, paired = TRUE)) %&gt;% tidy() %&gt;% mutate(model = unique(bs1_metric_summary$model)) ) %&gt;% rename(diff_in_means = estimate) %&gt;% arrange(desc(abs(diff_in_means))) %&gt;% mutate(model = as_factor(model)) # creates levels with current ordering all_means %&gt;% ggplot(aes(diff_in_means, model)) + geom_errorbarh(aes(xmin = conf.low, xmax = conf.high, height = 0.1)) + geom_point() + theme(legend.position = &quot;none&quot;, plot.title.position = &quot;plot&quot;) + labs(title = &quot;Difference in means between predicted and\\nactual log_light_avg&quot;, subtitle = &quot;T-test at 95% CI&quot;, x = &quot;difference in means&quot;, y = &quot;&quot;) Figure 3.21: Differences in the means (predicted v actual) TODO: write summary statement re: metrics all_metrics &lt;- bind_rows( lin3_metric_summary, pol1_metric_summary, xg1_metric_summary, bs1_metric_summary ) model_levels = all_metrics %&gt;% filter(.metric == &quot;ccc&quot;) %&gt;% arrange(.estimate) %&gt;% pull(model) all_metrics %&gt;% mutate(model = factor(model, levels = model_levels)) %&gt;% ggplot(aes(.estimate, model)) + geom_point() + geom_label(aes(label = str_pad(round(.estimate, 3), width = 5, side = &quot;right&quot;, pad = &quot;0&quot;) ), size = 3, nudge_x = -0.1, hjust = 1) + expand_limits(x = 0) + facet_wrap(~ .metric, scales = &quot;free_x&quot;) + theme(legend.position = &quot;none&quot;, plot.title.position = &quot;plot&quot;) + labs(title = &quot;Model evaluation on holdout data set&quot;, x = &quot;metric estimate&quot;, y = &quot;&quot;) Figure 3.22: Holdout set results all_metrics %&gt;% dplyr::select(-.estimator) %&gt;% arrange(.metric, desc(.estimate)) %&gt;% gt() %&gt;% tab_header( title = md(&quot;**Model evaluation on holdout data set**&quot;) ) %&gt;% fmt_number(columns = c(.estimate), decimals = 3) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #ddhmidilky .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ddhmidilky .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ddhmidilky .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ddhmidilky .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #ddhmidilky .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ddhmidilky .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ddhmidilky .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ddhmidilky .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ddhmidilky .gt_column_spanner_outer:first-child { padding-left: 0; } #ddhmidilky .gt_column_spanner_outer:last-child { padding-right: 0; } #ddhmidilky .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ddhmidilky .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #ddhmidilky .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ddhmidilky .gt_from_md > :first-child { margin-top: 0; } #ddhmidilky .gt_from_md > :last-child { margin-bottom: 0; } #ddhmidilky .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ddhmidilky .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #ddhmidilky .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ddhmidilky .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #ddhmidilky .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ddhmidilky .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ddhmidilky .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ddhmidilky .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ddhmidilky .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ddhmidilky .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #ddhmidilky .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ddhmidilky .gt_sourcenote { font-size: 90%; padding: 4px; } #ddhmidilky .gt_left { text-align: left; } #ddhmidilky .gt_center { text-align: center; } #ddhmidilky .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ddhmidilky .gt_font_normal { font-weight: normal; } #ddhmidilky .gt_font_bold { font-weight: bold; } #ddhmidilky .gt_font_italic { font-style: italic; } #ddhmidilky .gt_super { font-size: 65%; } #ddhmidilky .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Model evaluation on holdout data set .metric .estimate model ccc 0.962 lin3: log_light_avg ~ log_pop_density ccc 0.962 pol1: log_light_avg ~ poly(log_pop_density, 2) ccc 0.959 bs1: log_light_avg ~ bs(log_pop_density) ccc 0.935 xg1: log_light_avg ~ log_pop_density + state rsq 0.945 lin3: log_light_avg ~ log_pop_density rsq 0.945 pol1: log_light_avg ~ poly(log_pop_density, 2) rsq 0.939 xg1: log_light_avg ~ log_pop_density + state rsq 0.935 bs1: log_light_avg ~ bs(log_pop_density) "],["interpreting-the-results.html", "4 Interpreting the results 4.1 How much did the population density and radiance change between 2000 and 2010? 4.2 Conclusion", " 4 Interpreting the results As noted in the last section: The simpler models do better: lin3, pol1, and bs1 are essentially equal in performance while xg1 does worse and underestimates most radiance values. d_df &lt;- tar_read(all_df) %&gt;% # drop apparent data errors/artifacts filter(light_avg &gt; 1e-5) %&gt;% select(state, county, light_avg, log_light_avg, pop, calc_area, pop_density, log_pop_density) pop_density_2000_mean &lt;- sum(d_df$pop) / sum(d_df$calc_area) # summary of all states of interest (avoiding averages of averages) pop_density_2000_median &lt;- median(d_df$pop / d_df$calc_area) light_2000 &lt;- tar_read(light_sf) d_df_c &lt;- tar_read(all_df_c) %&gt;% # drop apparent data errors/artifacts filter(light_avg &gt; 1e-5) %&gt;% select(state, county, light_avg, log_light_avg, pop, calc_area, pop_density, log_pop_density) pop_density_2010_mean &lt;- sum(d_df_c$pop) / sum(d_df_c$calc_area) # summary of all states of interest (avoiding averages of averages) pop_density_2010_median &lt;- median(d_df_c$pop / d_df_c$calc_area) light_2010 &lt;- tar_read(light_sf_c) 4.1 How much did the population density and radiance change between 2000 and 2010? census_compare &lt;- d_df %&gt;% select(state, county, light_avg_2000 = light_avg, pop_density_2000 = pop_density, log_light_avg_2000 = log_light_avg, log_pop_density_2000 = log_pop_density) %&gt;% left_join(., d_df_c %&gt;% select(state, county, light_avg_2010 = light_avg, pop_density_2010 = pop_density, log_light_avg_2010 = log_light_avg, log_pop_density_2010 = log_pop_density ), by = c(&quot;state&quot;, &quot;county&quot;)) %&gt;% mutate(light_diff = light_avg_2010 - light_avg_2000, pop_density_diff = pop_density_2010 - pop_density_2000, pct_light_diff = light_avg_2010 / light_avg_2000 - 1, pct_pop_density_diff = pop_density_2010 / pop_density_2000 - 1) %&gt;% na.omit() census_compare_long &lt;- census_compare %&gt;% pivot_longer(cols = contains(c(&quot;2000&quot;, &quot;2010&quot;, &quot;diff&quot;)), names_to = &quot;metric&quot;, values_to = &quot;values&quot;) 4.1.1 From 2000 to 2010 radiance increased almost twice as much as population density County population density is up by ~13% overall in the states of interest, and median population density is up by 8.5%. Over the same time interval county average light radiance is up by a whopping 23%. What could account for such significant change in radiance? I see three main possibilities: Perhaps the result is real, and I’m missing confounding influences (U_pe and U_er in Figure 1.1). For example, in 2010 the country was early in recovery from the Great Recession, and interest rates (and bond financing for construction projects) were very low. Did this spark a building boom that increased radiance values? Perhaps I should consider the business cycle or other representation of relative economic activity. Perhaps the radiance levels have a lot of error in them, the intercalibration coefficients don’t do enough to allow valid multi-year comparisons, or there are other anomalies or influences (U_rad). Perhaps I made errors along the way. mean_summary &lt;- tribble( ~variable, ~mean_2000, ~mean_2010, ~median_2000, ~median_2010, &quot;light_avg&quot;, mean(light_2000$value), mean(light_2010$value), median(light_2000$value), median(light_2010$value), &quot;pop_density&quot;, pop_density_2000_mean, pop_density_2010_mean, pop_density_2000_median, pop_density_2010_median ) %&gt;% mutate(pct_diff_mean = mean_2010 / mean_2000 - 1, pct_diff_median = median_2010 / median_2000 - 1) mean_summary %&gt;% gt() %&gt;% tab_header( title = md(&quot;**County population density km^2 in 2000 and 2010**&quot;) ) %&gt;% fmt_number(columns = starts_with(c(&quot;mean&quot;, &quot;median&quot;)), decimals = 1) %&gt;% fmt_percent(columns = contains(&quot;diff&quot;), decimals = 1) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #osncjrvket .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #osncjrvket .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #osncjrvket .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #osncjrvket .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #osncjrvket .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #osncjrvket .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #osncjrvket .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #osncjrvket .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #osncjrvket .gt_column_spanner_outer:first-child { padding-left: 0; } #osncjrvket .gt_column_spanner_outer:last-child { padding-right: 0; } #osncjrvket .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #osncjrvket .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #osncjrvket .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #osncjrvket .gt_from_md > :first-child { margin-top: 0; } #osncjrvket .gt_from_md > :last-child { margin-bottom: 0; } #osncjrvket .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #osncjrvket .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #osncjrvket .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #osncjrvket .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #osncjrvket .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #osncjrvket .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #osncjrvket .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #osncjrvket .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #osncjrvket .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #osncjrvket .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #osncjrvket .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #osncjrvket .gt_sourcenote { font-size: 90%; padding: 4px; } #osncjrvket .gt_left { text-align: left; } #osncjrvket .gt_center { text-align: center; } #osncjrvket .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #osncjrvket .gt_font_normal { font-weight: normal; } #osncjrvket .gt_font_bold { font-weight: bold; } #osncjrvket .gt_font_italic { font-style: italic; } #osncjrvket .gt_super { font-size: 65%; } #osncjrvket .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } County population density km^2 in 2000 and 2010 variable mean_2000 mean_2010 median_2000 median_2010 pct_diff_mean pct_diff_median light_avg 14.2 17.5 7.9 8.6 23.0&percnt; 8.3&percnt; pop_density 46.0 52.0 24.0 26.1 13.1&percnt; 8.5&percnt; data_for_plot &lt;- bind_rows( census_compare %&gt;% select(log_light_avg = log_light_avg_2000, log_pop_density = log_pop_density_2000) %&gt;% mutate(year = &quot;2000&quot;), census_compare %&gt;% select(log_light_avg = log_light_avg_2010, log_pop_density = log_pop_density_2010) %&gt;% mutate(year = &quot;2010&quot;), ) p1 &lt;- data_for_plot %&gt;% ggplot() + geom_smooth(aes(log_pop_density, log_light_avg, color = year), se = FALSE) + scale_color_viridis_d(end = 0.9) + annotate(&quot;rect&quot;, xmin = 0, xmax = 1.3, ymin = 0, ymax = 1.1, alpha = .2) + labs(title = &quot;Comparing log_light_avg ~ log_pop_density&quot;, subtitle = &quot;Loess&quot;) p2 &lt;- data_for_plot %&gt;% ggplot() + geom_smooth(aes(log_pop_density, log_light_avg, color = year), method = &quot;lm&quot;, se = FALSE) + scale_color_viridis_d(end = 0.9) + annotate(&quot;rect&quot;, xmin = 0, xmax = 1.3, ymin = 0, ymax = 1.1, alpha = .2) + labs(subtitle = &quot;lm&quot;) In the loess regression line I see the underlying reason that the models performed as they did … compare to Figures … TODO: confirm this (p1 + p2) + plot_layout(guides = &#39;collect&#39;) + theme(plot.margin = unit(c(10, 0, 5, 0), &quot;mm&quot;)) Figure 4.1: Comparing regression lines in 2000 and 2010 (loess and lm) 4.1.2 Exploring changes in radiance and population density 2000 and 2010 The following density plots indicate a large portion of low-density counties lost population (a continuation of rural counties hollowing out) with growth happening in relatively few counties. An even smaller portion of the counties had increased radiance in 2010. census_compare_long %&gt;% filter(str_detect(metric, &quot;pct&quot;)) %&gt;% ggplot(aes(x = values, y = metric, color = metric, fill = metric)) + geom_density_ridges(rel_min_height = 0.005, alpha = 0.4) + scale_x_continuous(labels = percent_format(accuracy = 1)) + scale_color_viridis_d(end = 0.8) + scale_fill_viridis_d(end = 0.8) + labs(title = &quot;Percentage difference - density plot&quot;, subtitle = &quot;Values: 2010 / 2000 - 1&quot;) Figure 4.2: Percentage difference in population density and radiance 2000 and 2010 Compared to 2000, the radiance values from 2010 are not as concentrated, and at values larger than the mode, the density curve shifts right. census_compare_long %&gt;% filter(metric %in% c(&quot;light_avg_2000&quot;, &quot;light_avg_2010&quot;)) %&gt;% ggplot(aes(x = values, color = metric, fill = metric)) + geom_density(alpha = 0.4) + scale_x_log10(labels = label_number_si()) + scale_color_viridis_d(end = 0.8) + scale_fill_viridis_d(end = 0.8) + labs(title = &quot;County light radiance &quot;, subtitle = &quot;2010 and 2000 census values&quot;, x = &quot;values (log10 scale)&quot;) Figure 4.3: County average radiance 2000 and 2010 Looking at population density values rather than differences, in 2010 I see more counties in the range 30-400 per sq km (37 - 154 per sq mi) range. census_compare_long %&gt;% filter(metric %in% c(&quot;pop_density_2000&quot;, &quot;pop_density_2010&quot;)) %&gt;% ggplot(aes(x = values, color = metric, fill = metric)) + geom_density(alpha = 0.3) + scale_x_log10(labels = label_number_si()) + scale_color_viridis_d(end = 0.8) + scale_fill_viridis_d(end = 0.8) + labs(title = &quot;Country population density&quot;, subtitle = &quot;2010 and 2000 census values&quot;, x = &quot;values (log10 scale)&quot;) Figure 4.4: County population density 2000 and 2010 Looking at percent changes in population density with pop_density_2000 on the x-axis, I see similar trends in each state: TODO: add a comment here (or remove graph as “not interesting”) census_compare %&gt;% ggplot(aes(x = pop_density_2000, y = pct_pop_density_diff, color = state)) + geom_point(alpha = 0.15) + geom_smooth(se = FALSE, size = 0.5) + scale_x_log10() + scale_y_continuous(labels = percent_format()) + expand_limits(y = c(-0.5, 1.0)) + labs(title = glue(&quot;Which counties had the biggest changes\\nin population density?&quot;), subtitle = &quot;2000 to 2010&quot;, x = &quot;pop_density_2000 (log scale)&quot; ) Figure 4.5: Changes in population density 2000-2010 As expected, the biggest percentage changes in radiance values occurred in the darkest counties (radiance &lt; 30), where a small change in radiance is a large percentage change. census_compare %&gt;% ggplot(aes(x = light_avg_2000, y = pct_light_diff, color = state)) + geom_point(alpha = 0.15) + geom_smooth(se = FALSE, size = 0.5) + scale_x_log10() + scale_y_continuous(labels = percent_format()) + labs(title = glue(&quot;Which counties had the biggest changes\\nin avg radiance?&quot;), subtitle = &quot;2000 to 2010&quot;, x = &quot;light_avg_2000 (log scale)&quot; ) Figure 4.6: Changes in radiance 2000-2010 The relationship between pct_pop_density_diff and pct_light_diff is remarkably linear in summary, albeit with wide variance: census_compare %&gt;% ggplot(aes(x = pct_pop_density_diff, y = pct_light_diff, color = pop_density_2000, size = pop_density_2000)) + geom_point(alpha = 0.25) + geom_smooth(se = FALSE, size = 0.5) + geom_smooth(method = &quot;lm&quot;, color = &quot;firebrick&quot;, se = FALSE, size = 0.5) + scale_x_continuous(labels = percent_format()) + scale_y_continuous(labels = percent_format()) + scale_color_gradient2(low = &quot;black&quot;, mid = &quot;green&quot;, high = &quot;orange&quot;, midpoint = log10(pop_density_2000_median), trans=log10_trans()) + guides(size = &quot;none&quot;) + labs(title = glue(&quot;pct_light_diff by pct_pop_density_diff&quot;), subtitle = &quot;2000 to 2010&quot; ) Figure 4.7: There is near-linear relationship in the percent difference of county radiance and county population density between 2000 and 2010 4.2 Conclusion TODO: add more here "],["end-notes.html", "5 End notes 5.1 Acknowlegements 5.2 Data provenance 5.3 Assumptions and limitations 5.4 Project organization", " 5 End notes 5.1 Acknowlegements Image and data processing by Earth Observation Group, Payne Institute for Public Policy, Colorado School of Mines. DMSP data collected by US Air Force Weather Agency. Special thanks to … Daynan Crull, Trevor Monroe and the world bank for their Open Night Lights tutorial, presented as part of the 3rd Annual Geo4Dev Symposium &amp; Workshop December 10-11, 2020. Robin Lovelace, Jakub Nowosad, and Jannes Muenchow for the very helpful Geocomputation with R, which is now available as a physical book from CRC Press. Edzer Pebesma and all those who have been working on sf and terra in recent years. July 2021 overview: https://edzer.github.io/UseR2021/#1 Kyle Walker, Matt Herman, and Kris Eberwein for the tidycensus package The RStudio team and other contributors to the tidyverse and tidymodels package families. Max Kuhn and Julia Silge for Tidy Modeling with R. I used Version 0.0.1.9010 (2021-07-19). CRAN maintainers and the R Foundation for fostering a high-quality, growing R ecosystem. 5.2 Data provenance 5.2.1 Version 4 DMSP-OLS Nighttime Lights Time Series From https://eogdata.mines.edu/products/dmsp/ Since the 1970s, the U.S. Air Force Defense Meteorological Satellite Program (DMSP) has operated satellite sensors capable of detecting the visible and near-infrared (VNIR) emissions from cities and towns. The DMSP Operational Linescan System (OLS) acquires global daytime and nighttime imagery of the Earth in two spectral bands (VIS and TIR). The nighttime “VIS” bandpass straddles the VNIR portion of the spectrum (0.5 to 0.9 um). The VIS band signal is intensified at night using a photomultiplier tube (PMT), making it possible to detect faint VNIR emission sources. The PMT system was implemented for the detection of clouds at night. An unanticipated consequence of the nighttime light intensification is the detection of city lights, gas flares, and fires. Since 1997, EOG had been pioneering in combining the imagery taken by DMSP-OLS to produce global Nighttime Light maps. With annual data stretch from 1992 to 2013, making DMSP Nighttime Light the longest data series available for nocturnal remote sensing on human activities. From https://eogdata.mines.edu/dmsp/downloadV4composites.html The files are cloud-free composites made using all the available archived DMSP-OLS smooth resolution data for calendar years. In cases where two satellites were collecting data - two composites were produced. The products are 30 arc second grids, spanning -180 to 180 degrees longitude and -65 to 75 degrees latitude. Citations: These data sets are the results of years of algorithm development and production efforts. The data are here for you and others to use in any way you like and have no copyright. Please acknowledge our efforts by including a brief data source attribution and one or more of the following references in anything you write where our data is utilized. Data source attribution “Earth Observation Group, Colorado School of Mines.” References: Elvidge, C. D., Baugh, K. E., Kihn, E. A., Kroehl, H. W., &amp; Davis, E. R. (1997). Mapping city lights with nighttime data from the DMSP Operational Linescan System. Photogrammetric Engineering and Remote Sensing, 63(6), 727-734. Baugh, K., Elvidge, C. D., Ghosh, T., &amp; Ziskin, D. (2010). Development of a 2009 stable lights product using DMSP-OLS data. Proceedings of the Asia-Pacific Advanced Network, 30(0), 114. 5.2.2 Radiance data I use Radiance Calibrated values(Hsu et al. 2015), a transformation of the Digital Number (DN) made available by the EOG group at https://eogdata.mines.edu/products/dmsp/#v4_dmsp_download From https://eogdata.mines.edu/products/dmsp/#radcal : The Operational Linescan System (OLS) flown on the Defense Meteorological Satellite Program (DMSP) satellites, has a unique capability to record low light imaging data at night worldwide. These data are archived at the National Oceanic and Atmospheric Administration (NOAA) National Geophysical Data Center (NGDC). The useful data record stretches back to 1992 and is ongoing. The OLS visible band detector observes radiances about one million times dimmer than most other Earth observing satellites. The sensor is typically operated in a high gain setting to enable the detection of moonlit clouds. However, with six bit quantization and limited dynamic range, the recorded data are saturated in the bright cores of urban centers. A limited set of observations have been obtained at low lunar illumination were obtained where the gain of the detector was set significantly lower than its typical operational setting (sometimes by a factor of 100). By combining these sparse data acquired at low gain settings with the operational data acquired at high gain settings, we have produced a set of global nighttime lights product with no sensor saturation. This product can be related to radiances based on the pre-flights sensor calibration. See the Global Radiance Calibrated Nighttime Lights Product Readme for a summary of the methodology. These files align with the US decennial census, which has the highest-quality demographic data. I downloaded the image files on 2021-07-17. F12-F15_20000103-20001229_rad_v4.geotiff.tgz (F12-F15_20000103-20001229_rad_v4); using F12-F15_20000103-20001229_rad_v4.avg_vis.tif F16_20100111-20110731_rad_v4.geotiff.tgz (F16_20100111-20110731_rad_v4); using F16_20100111-20110731_rad_v4.avg_vis.tif 5.2.3 Intercalibration https://eogdata.mines.edu/products/dmsp/ I use the EOG’s Radiance Calibrated products, which have data for the years I want and requires intersatellite and inter-annual calibration in order to make valid comparisons. The coefficient table is available in DMSP-OLS Radiance Calibrated Nighttime Lights Time Series with Intercalibration(Hsu et al. 2015): The Defense Meteorological Satellite Program-Operational Linescan System (DMSP-OLS) stable lights products are made using operational OLS data collected at high gain settings, resulting in sensor saturation on brightly lit areas, such as city centers. This has been a paramount shortcoming of the DMSP-OLS stable lights time series. This study outlines a methodology that greatly expands the dynamic range of the OLS data using observations made at different fixed-gain settings, and by incorporating the areas not affected by saturation from the stable lights product. The radiances for the fixed-gain data are computed based on each OLS sensor’s pre-flight calibration. The result is a product known as the OLS radiance calibrated nighttime lights. A total of eight global datasets have been produced, representing years from 1996 to 2010. To further facilitate the usefulness of these data for time-series analyses, corrections have been made to counter the sensitivity differences of the sensors, and coefficients are provided to adjust the datasets to allow inter-comparison. page 1868 includes the relevant coefficients, as does the Global Radiance Calibrated Nighttime Lights Product Readme: Inter-satellite Calibration Multiplier. Satellite Base Gain (dB) Multiplier Radiance @ DN1 (W/cm2/sr) F14 55 0.82 1.23E-10 F16 55 1.0 1.50E-10 Note all [radiance] products are inter-satellite calibrated to the base gain setting of 55 dB of satellite F16. (page 1872) Thus, to perform inter-satellite calibration, I multiplied the radiance values in the F14 GeoTIFF image by 0.82. While this improves the comparability in time series, it contributes its own sources of error, as summarized below. I take the Inter-annual Calibration Coefficients directly from the Global Radiance Calibrated Nighttime Lights Product Readme: NOTE: (1) This table is preliminary, and needs to be updated. (2) There is no data for &quot;F16_20051128-20061224_rad_v4&quot; for it being the reference dataset. (3) F16_20100111-20101209_rad_v4 and F16_20100111-20110731_rad_v4 share the same data for there is onyl small diferrence from adding images from year 2011. Equation Y=Coeff0+Coeff1*X Y-File F16_20051128-20061224_rad_v4 X-File Pow Coeff0 Coeff1 R2 N_Pt F12_19960316-19970212_rad_v4 1 4.336 0.915 0.971 20540 F12_19990119-19991211_rad_v4 1 1.423 0.780 0.980 20846 F12-F15_20000103-20001229_rad_v4 1 3.658 0.710 0.980 20866 &lt;- F14-F15_20021230-20031127_rad_v4 1 3.736 0.797 0.980 20733 F14_20040118-20041216_rad_v4 1 1.062 0.761 0.984 20844 F16_20100111-20101209_rad_v4 1 2.196 1.195 0.981 20848 &lt;- F16_20100111-20110731_rad_v4 1 -1.987 1.246 0.981 20848 Thus to make values comparable across years, I further transform the 2000 radiance values: \\[Y=Coeff_0+Coeff_1 * X = 3.658 + 0.710 * X\\] where X is the vector of radiance values. Similarly for 2010: \\[Y=Coeff_0+Coeff_1 * X = 2.196 + 1.195 * X\\] Note the \\(R^2\\) values above. This adjustment is introducing error. 5.3 Assumptions and limitations 5.3.1 Limitations 5.3.1.1 Limitations in nighttime lights data The World Bank’s Open Nighttime Lights tutorial (WorldBank 2020) summarizes the following limitations (among others): 2.2.2. Limitations and challenges of DMSP-OLS Low radiometric resolution (6-bit data, values range from 0-63) No on-board calibration Large spatial resolution (4.9km for nighttime VIS band) Saturation in urban cores These limitations can lead to challenges for scientists using these data for their work. For example, drawing conclusions from the DMSP-OLS stable lights series may be challenging in low-density urban areas …. In addition, the extent and intensity of lit areas cannot directly delimit urban regions due to the “blooming” effect. Radiance Calibrated is not absolute radiance(Hsu et al. 2015) Many users would like to relate the DN values in the Radiance Calibrated products to actual radiance. The fixed-gain image avoids the automatic gain variation by VDGA which is not recorded in the data stream. So theoretically, by applying the preflight sensor calibration, the actual radiance could be derived from the DN. Nevertheless, even under such controlled operation, there is no means to address the degradation of the equipment without an on board calibration device. Moreover, the uncertainty brought by blending Stable Light products, which were taken under variable gain settings, make it even more unlikely to derive the exact radiance from the Radiance Calibrated product. As a result, it is suggested that the Radiance Calibrated product is only suitable for analyses which do not require actual radiance. Nevertheless, the conversion factor from DN to radiance for the Radiance Calibrated products is listed in Table 3 for reference. Note all products are inter-satellite calibrated to the base gain setting of 55 dB of satellite F16. (page 1872) and Because the DMSP-OLS does not carry an on-board calibration device for the visible band, it is not possible to track how actual radiance is being converted to DN even if the auto-adjust gain setting is fixed. Instead we rely on the preflight calibration made for each OLS instrument prior to launch. Therefore, even though the Radiance Calibrated products are made from data collected under much more controlled setting than the Stable Lights products, the radiance values should still be considered relative and not absolute. (page 1874) In this analysis I refer to these Radiance Calibrated values as “radiance” and “radiance values” 5.3.1.2 Limitations in intercalibration As summarized in (Hsu et al. 2015) Being freed from the saturation problem, Radiance Calibrated products need a reference area which not only is stable enough but also provides samples with brightness ranging from very low light to the world’s highest levels. Los Angeles was taken as the reference for the Radiance Calibrated products for two reasons. First, Los Angeles has long been a mature metropolis and the light change is negligible. Second, being a metropolis, it can provide samples with high DNs from the city center, as well as low DNs from the suburban area. While the distribution of light data from L.A. over the time period may have been relatively stable, the differences probably weren’t zero, and the error or bias is not quantified. In fact the readme includes the following related to inter-annual calibration: This table is preliminary, and needs to be updated. The readme includes the following: Date: 01/15/2015 Modified: 09/09/2020 Typical uncertainty of sensors noted in (Chander et al. 2013): In general, the absolute radiometric calibration for most optical sensors is specified to an uncertainty of 5%; hence, the likely uncertainty (in reflectance units) on a measured reflectance value of, for example, 0.4 will be ±5% of 0.4 equal to ±0.02. (page 1058) Scene Variability can source of error, however in this case, use of light averaged over data collected at various times throughout the year minimizes this source. The intercalibration of satellite instruments often requires comparing observations from different instruments coincident in space, time, and viewing geometry. As these are never exactly aligned, thresholds are usually applied to define the collocations. The choice of these thresholds directly impacts the uncertainty of the comparison, partially due to the scene variability within the range of the collocation criteria. The collocation criteria represent tradeoffs between the errors on each collocation and the number of collocations available. Collocated observations from a pair of satellite instruments are not sampled at exactly the same place or time. Variations in the atmosphere and surface during the interval between their observations introduce errors when comparing their collocated radiances. The greater the collocated observations interval, the larger the contribution of the scene’s variability to the total error budget. (page 1061) 5.3.2 Census data and state and county geometry This analysis used three sources of data: US census 2000, which provided total population by county and median income by county. US census 2010, which provided total population by county. This decennial census did not provide median household income (in fact, the 2010 census did away with the “long form” that provided the data for the sf3 table). Five-year ACS (2006-2010), which provided total population by county and median income by county. These population estimates are ~2% lower than the 2010 census for the counties I examined in this analysis. In the end I did not use median income in my regression equations, so I did not need to deal with differences in methodology between the decennial census and ACS, nor did I need to adjust for inflation. The tidycensus package provides the population data from 2000 and 2010 decennial censuses. Median income per family comes from the decennial 2000 census and the American Community Survey (ACS) five-year estimates 2006-2010 provided by the US Census Bureau. tidycensus also provides state and county geometry via the tigris package (and corresponding extracts from the Census Bureau’s Master Address File/Topologically Integrated Geographic Encoding and Referencing (TIGER) database). 5.3.3 Population and population density I used these county boundaries to calculate the area of each county and (combined with decennial census population), each county’s population density. I included land and water area when calculating total area, since my calculation of average light radiance per county used the same boundaries that included land and water within those boundaries I did not do anything to adjust for light blooming beyond what EOG did in their radiance products. Instead I assume blooming artifacts are similar in the 2000 and 2010 products. On the coasts and in other high-traffic areas, census population (and therefore population density) may not capture vacationers and other itinerant people that contribute to population density, and (if my causal conjecture holds), the degree to which an area is built up and generated light. I assume any effect due to itinerant people is small enough that it can be ignored. 5.3.4 Economic development / GDP / business cycle The US was in the middle of the Great Recession in 2010. Could this be a factor in the lower radiance levels that year compared to 2000? Starting in 2008, the recession depressed new investments, including building projects that would have created more nighttime light. This may have contributed to slower growth in radiance, however it’s unlikely to have caused light levels in 2010 to be lower than 2000. Consider: shopping malls and hotels may have had lower occupancy and fewer customers, but they would have left the lights on in their parking lots. 5.4 Project organization 5.4.1 Data preparation pipeline implemented to with targets package Dependencies among a set of functions are specified in the _targets file and executed via tar_make(). They include the following: tar_manifest() %&gt;% arrange(name) %&gt;% gt() ## here() starts at /Users/dmoul/rwork/nightlight html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #yyichzgjis .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #yyichzgjis .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yyichzgjis .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #yyichzgjis .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #yyichzgjis .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yyichzgjis .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yyichzgjis .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #yyichzgjis .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #yyichzgjis .gt_column_spanner_outer:first-child { padding-left: 0; } #yyichzgjis .gt_column_spanner_outer:last-child { padding-right: 0; } #yyichzgjis .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #yyichzgjis .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #yyichzgjis .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #yyichzgjis .gt_from_md > :first-child { margin-top: 0; } #yyichzgjis .gt_from_md > :last-child { margin-bottom: 0; } #yyichzgjis .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #yyichzgjis .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #yyichzgjis .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yyichzgjis .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #yyichzgjis .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yyichzgjis .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #yyichzgjis .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #yyichzgjis .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yyichzgjis .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yyichzgjis .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #yyichzgjis .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yyichzgjis .gt_sourcenote { font-size: 90%; padding: 4px; } #yyichzgjis .gt_left { text-align: left; } #yyichzgjis .gt_center { text-align: center; } #yyichzgjis .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #yyichzgjis .gt_font_normal { font-weight: normal; } #yyichzgjis .gt_font_bold { font-weight: bold; } #yyichzgjis .gt_font_italic { font-style: italic; } #yyichzgjis .gt_super { font-size: 65%; } #yyichzgjis .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } name command pattern all_df model_prepare_data(county_sf) NA all_df_c model_prepare_data(county_sf_c) NA bbox_vec get_bbox(census_df, these_states) NA census_df get_census_data(all_states, census_year_a, \"census\") NA census_df_c get_census_data(all_states, census_year_c, \"census\") NA census_focus_df census_focus(census_df, these_states, bbox_vec) NA census_focus_df_c census_focus(census_df_c, these_states, bbox_vec) NA county_sf get_county_light_sf(census_focus_df, light_sf) NA county_sf_c get_county_light_sf(census_focus_df_c, light_sf_c) NA light_points_df get_light_levels(bbox_vec, source_light_file_2000, \\n intersat_calibration = 0.82, interannual_calibration = c(3.658, \\n 0.71)) NA light_points_df_c get_light_levels(bbox_vec, source_light_file_2010, \\n intersat_calibration = 1, interannual_calibration = c(2.196, \\n 1.195)) NA light_sf get_light_sf(light_points_df, state_boundaries_geom) NA light_sf_c get_light_sf(light_points_df_c, state_boundaries_geom) NA state_boundaries_geom state_boundaries(census_focus_df) NA tar_visnetwork() provides a dependency graph. Zoom in to see the labels on the nodes: tar_visnetwork() ## here() starts at /Users/dmoul/rwork/nightlight 5.4.2 Session information sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Big Sur 10.16 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] splines stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] gt_0.3.1 multilevelmod_0.0.0.9000 yardstick_0.0.8 ## [4] workflowsets_0.1.0 workflows_0.2.3 tune_0.1.6 ## [7] rsample_0.1.0 recipes_0.1.16 parsnip_0.1.7 ## [10] modeldata_0.1.1 infer_1.0.0 dials_0.0.9 ## [13] broom_0.7.9 tidymodels_0.1.3 hrbrthemes_0.8.6 ## [16] scales_1.1.1 units_0.7-2 tidycensus_1.0 ## [19] patchwork_1.1.1 ggdag_0.2.3 dagitty_0.3-1 ## [22] ggridges_0.5.3 terra_1.3-22 sf_1.0-2 ## [25] glue_1.4.2 forcats_0.5.1 stringr_1.4.0 ## [28] dplyr_1.0.7 purrr_0.3.4 readr_2.0.1 ## [31] tidyr_1.1.3 tibble_3.1.4 ggplot2_3.3.5 ## [34] tidyverse_1.3.1 targets_0.7.0 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.3.1 uuid_0.1-4 backports_1.2.1 systemfonts_1.0.2 ## [5] plyr_1.8.6 igraph_1.2.6 sp_1.4-5 listenv_0.8.0 ## [9] digest_0.6.27 foreach_1.5.1 htmltools_0.5.2 fansi_0.5.0 ## [13] checkmate_2.0.0 magrittr_2.0.1 doParallel_1.0.16 tzdb_0.1.2 ## [17] globals_0.14.0 modelr_0.1.8 gower_0.2.2 extrafont_0.17 ## [21] extrafontdb_1.0 hardhat_0.1.6 colorspace_2.0-2 rvest_1.0.1 ## [25] rappdirs_0.3.3 haven_2.4.3 xfun_0.25 rgdal_1.5-23 ## [29] callr_3.7.0 crayon_1.4.1 jsonlite_1.7.2 iterators_1.0.13 ## [33] survival_3.2-13 tigris_1.4.1 gtable_0.3.0 ipred_0.9-11 ## [37] V8_3.4.2 Rttf2pt1_1.3.9 DBI_1.1.1 Rcpp_1.0.7 ## [41] GPfit_1.0-8 foreign_0.8-81 proxy_0.4-26 lava_1.6.9 ## [45] prodlim_2019.11.13 htmlwidgets_1.5.3 httr_1.4.2 ellipsis_0.3.2 ## [49] pkgconfig_2.0.3 nnet_7.3-16 sass_0.4.0 dbplyr_2.1.1 ## [53] utf8_1.2.2 here_1.0.1 tidyselect_1.1.1 rlang_0.4.11 ## [57] DiceDesign_1.9 visNetwork_2.0.9 munsell_0.5.0 cellranger_1.1.0 ## [61] tools_4.1.0 cli_3.0.1 generics_0.1.0 evaluate_0.14 ## [65] fastmap_1.1.0 yaml_2.2.1 processx_3.5.2 knitr_1.33 ## [69] fs_1.5.0 tidygraph_1.2.0 future_1.22.1 xml2_1.3.2 ## [73] compiler_4.1.0 rstudioapi_0.13 curl_4.3.2 e1071_1.7-8 ## [77] reprex_2.0.1 lhs_1.1.1 bslib_0.2.5.1 stringi_1.7.4 ## [81] ps_1.6.0 gdtools_0.2.3 lattice_0.20-44 Matrix_1.3-4 ## [85] classInt_0.4-3 vctrs_0.3.8 pillar_1.6.2 lifecycle_1.0.0 ## [89] furrr_0.2.3 jquerylib_0.1.4 data.table_1.14.0 maptools_1.1-1 ## [93] raster_3.4-13 R6_2.5.1 bookdown_0.23 KernSmooth_2.23-20 ## [97] parallelly_1.27.0 codetools_0.2-18 boot_1.3-28 MASS_7.3-54 ## [101] assertthat_0.2.1 rprojroot_2.0.2 withr_2.4.2 parallel_4.1.0 ## [105] hms_1.1.0 grid_4.1.0 rpart_4.1-15 timeDate_3043.102 ## [109] class_7.3-19 rmarkdown_2.10 pROC_1.17.0.1 lubridate_1.7.10 References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
